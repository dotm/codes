// Heap

// Array: [1,2,3,4,5,6]
// Heap:
   1
  / \
 2   3
/ \ /
4 5 6

// Assumption: heap's first element is on index number 1 (not zero-indexed)
// Heap has:
// heapSize property

// Get parent method
  // Divide current node index number by 2 and
  // round down the result to get parent node index
// Get left child method
  // left child index is current node index multiplied by 2
// Get right child method
  // right child index is current node index multiplied by 2 and then added by one

//-----------------------
// Max-heap
// is a Heap where a node is always greater than or equal to than its children node

// Max-heap has:

// Max-heapify method: used to maintain the max-heap property ( A[PARENT(i)] >= A[i] )
  // If left children is within heapSize (in the heap) and is bigger than its parent
    // switch both node
  // If right children is within heapSize (in the heap) and is bigger than its parent
    // switch both node
  // If a smaller parent is switched and become a children,
    // do this method again to the switched smaller element until max-heap property is satisfied
    
// Build-max-heap method: produces a max-heap from an unordered input array
  // The elements in the subarray A[(floor(n/2)+1) .. n] are all leaves of the tree, and so
  // start doing Max-heapify from the top non-leave element ( floor(A.length/2) ) to the bottom ( A[i] )
  
// Max-heap sorting method
  // Build-max-heap of the array
  // While heapSize is not zero
    // Pick the root of the heap, push the whole heap array to the left, put the ex-root at the end of the heap
    // Decrease the heap size by one
    // Call Max-heapify on the heap to maintain the max-heap property
  // Return the sorted result