RDBMS: relational database management system

relation := table
attribute := column
tuple := row
type := domain (of attribute)
key: attribute whose value is unique in each tuple
	or set of attributes whose combined values are unique
	usually annotated with an underline

querying: asking question to database
query return relations as output from a set of relation as input, and is closed and compositional
	closed: you get back the same type of object that you query, that's known as closure of the language
	compositional: the ability to run a query over the result of our previous query

schema: structural description of relations in database
	includes name and attributes of the relation and the types of those attributes
instance: the actual contents of the table at a given point in time

NULL := unknown or undefined
	NULL value can be in any domain
	
database application may be programmed via framework e.g. Django, Rails
DBMS may run in conjunction with middle-ware e.g. application server, web server
data-intensive applications may not use DBMS at all e.g. Excel spreadsheet

data model e.g. set of records(in relational data model), hierarchical structure (XML), set of nodes and edges (graph data model)
data definition language (DDL): normally used to set up the schema
data manipulation language (DML): used to start querying and modifying the data once the schema has been set up and data has been loaded

Key people in DBMS
	DBMS implementer: build the database system
	database designer: establish database schema
	database application developer: build the application and program that run on the database, interfacing user and data
	database administrator: load the database's data and keep the database running smoothly

Creating and using a relational database
	design schema
	create schema using DDL
	bulk load initial data
	query and modify database continuously
	
SQL is a declarative language
	in SQL, you'll write pretty simple queries that say exactly what you want 
		you do not need to describe how to get that
	SQL use query optimizer that takes a query and figures out the best, fastest way, to execute that query

query tuning: ways to optimize query manually
	steps:
		identify what queries you want to tune
		understand how a particular SQL engine is executing a query
		manual optimization to improve that execution plan
		
#--------------------------------------------------------------------------------
#DDL
create table
drop table

#DML

#querying
#Select statement
	SELECT 		attribute1, attribute2 (what to return)
	FROM		Relation1, Relation2						#multiple relation is called a join statement
	WHERE		conditions									#use connective (and, or) to create compound proposition
	ORDER BY	attribute1, attribute2 DESC					#attribute2 to sort each attribute1 group. desc for descending; the default is ascending
	;														#end of statement
  use * to select all attributes
  to get rid of duplicates use: select distinct attributes
  if you use multiple relation, make sure to check the key match in Where:
	WHERE Relation1.name = Relation2.name
  when you use multiple relation and try to select an attribute that exists in more than one relation,
	use dot notation in Select to avoid ambiguous value: Relation1.name
  you can do arithmetic in the select statement
	SELECT attribute1 / (attribute2 + 1) as new_attribute		#use as to make the new attribute title new_attribute

#Where clause
	#Arithmetic operator: = >= <= > < <>
		advanced operator: ABS LIKE
			WHERE attribute LIKE '%string%'
	#Condition		e.g. name <> value
	#Logical operator: AND OR NOT	(precedence: (parentheses) > NOT > AND > OR)
		WHERE NOT condition AND condition
	#Quantifier: ALL ANY
		quantifier isn't a necessary feature in DBMS since you can use exists and not exists
	#Check if exists
		WHERE EXISTS (sub-query)	#or NOT EXISTS
	  check whether a sub-query is empty or not

#Sub-queries
Sub-queries are nested, select statements within the condition
	WHERE condition IN (SELECT attribute FROM Relation WHERE condition)
		AND condition NOT IN (sub-query)		#condition NOT IN := NOT condition IN
		OR NOT condition IN (sub-query)

If we use a sub query in the from, what we're really doing is running and that's the select statement that's going to
generate one of the tables that we use in the rest of the query.
If we use a sub query in the select, then what we're doing is writing a select expression, a sub select expression,
that produces the value that comes out of the query.

from (sub-query) G


#modifying
insert
delete
update

#--------------------------------------------------------------------------------
Khan Academy SQLite
#--------------------------------------------------------------------------------
NEVER forget the ;
CREATE TABLE table_name (id INTEGER PRIMARY KEY, attribute TYPE, multi-word_attribute TYPE);
	basic types: TEXT, NUMERIC, INTEGER, REAL, NONE

INSERT INTO table_name VALUES (id, value, value);
INSERT INTO table_name (id, attribute) VALUES (id, value);			#with this you don't have to input all value

CREATE TABLE table_name (id INTEGER PRIMARY KEY AUTOINCREMENT, attribute TYPE);
	INSERT INTO table_name (attribute) VALUES (value);				#with this you don't have to input id

#Aggregating and Aliasing
SELECT MAX(attribute) FROM table_name;
SELECT SUM(attribute) FROM table_name AS total_attribute;
	#Common aggregate functions:
		AVERAGE() 		#arithmetic mean)
		COUNT()
		MAXIMUM()
		MINIMUM()
		NANMEAN() 		#mean ignoring NaN values (or undefined values or 'nil's)
		MEDIAN()
		MODE()
		SUM()
		ROUND()

#IN
WHERE attribute1 = value1 OR attribute1 = value2;
	:= WHERE attribute1 IN (value1, value2);
	
SELECT * FROM table_name WHERE attribute1 IN (SELECT attribute1 FROM table_name1);
	select all attributes from table_name if the table_name.attribute1 also exists in table_name1.attribute1
SELECT title FROM songs WHERE artist IN (SELECT name FROM artists WHERE name = "Queen");

#Restricting group result
  HAVING : WHERE for GROUP
	SELECT 		attribute1, attribute2
	FROM		Relation1, Relation2
	GROUP BY	attribute1
	HAVING		conditions

#CASE
SELECT 			attribute1, attribute2,			#the CASE will be the third attribute
	CASE 
        WHEN condition THEN value
        WHEN condition THEN value1
        ELSE value2
    END AS "attribute3"
FROM			Relation1, Relation2

SELECT type, heart_rate,
    CASE 
        WHEN heart_rate > 220-30 THEN "above max"
        WHEN heart_rate > ROUND(0.90 * (220-30)) THEN "above target"
        WHEN heart_rate > ROUND(0.50 * (220-30)) THEN "within target"
        ELSE "below target"
    END as "hr_zone"
FROM exercise_logs;

SELECT COUNT(*),
CASE
    WHEN number_grade > 90 THEN 'A'
    WHEN number_grade > 80 THEN 'B'
    WHEN number_grade > 70 THEN 'C'
    ELSE 'F'
END AS letter_grade 
FROM student_grades
GROUP BY letter_grade;

#Joining table
	#Cross join
		SELECT * FROM Relation1, Relation2;
	  cross join: for each row in Relation1, it creates the rows from Relation2 (Relation1 X Relation2)
	#Implicit inner join
		SELECT * FROM Relation1, Relation2 WHERE Relation1.id = Relation2.foreign_id;
	  inner join: match the primary key of Relation1 to foreign key of Relation2 to avoid duplicates
	  using this is not best practice; explicit is better than implicit
	#Explicit inner join using JOIN keyword
		SELECT * FROM Relation1 JOIN Relation2 ON Relation1.id = Relation2.foreign_id;
	  you can still use WHERE etc with this query
	#Outer join
		SELECT * FROM left_table
		LEFT OUTER JOIN right_table						#show all row from left_table even if the value of it in right_table is NULL
		ON left_table.id = right_table.foreign_id;
	  some languages support RIGHT OUTER and FULL OUTER
	#Self join
		SELECT students.first_name, students.last_name, buddies.email as buddy_email
		FROM students
		JOIN students buddies					#buddies is alias to differentiate it from students; AS is optional
		ON students.buddy_id = buddies.id;
	#Multiple join
		SELECT a.title, b.title FROM project_pairs		#project_pairs has 3 rows: id, project1_id, project2_id
		JOIN student_projects a
		ON project_pairs.project1_id = a.id
		JOIN student_projects b
		ON project_pairs.project2_id = b.id;

#UPDATE
	UPDATE table_name SET attribute = value WHERE id = 1;
  you can use attribute or set of attributes other than id in the WHERE clause
	but it's always safer to use id

#DELETE
	DELETE FROM table_name WHERE id = 1;

#ALTER
  you can't modify CREATE when altering database schema unless you want all the data stored to be deleted
	ALTER TABLE table_name ADD attribute TYPE;
	
#Setting default value of attribute
	ALTER TABLE table_name ADD attribute TYPE default value;
	
#Deleting table
	DROP TABLE table_name

#--------------------------------------------------------------------------------
#What to learn next
features: indexes and query planning, constraints, triggers, views, and foreign keys. 
different versions of SQL: MySQL, PostGreSQL, Oracle, MS SQL, and DB2
theories, principles, and design: relational design theory (relational model), relational algebra and unified modelling language. 

