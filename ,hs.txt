#Initialize cmd
	ghci
	:set prompt "ghci> "
#Exit ghci
	:quit	#or ctrl-D

#Comment
{- A multiline comment  -}
-- a single line comment

#Loading function(module)
:l file_name

#Let keyword
Doing let a = 1 inside GHCI is equivalent of writing a = 1 in a script and then loading it.
let can NOT be used when using copmiler

#Arithmetic operators: + - * / div mod
#Boolean operators: && || not
#Comparators: == /= <= >= < >

#-------------------------------------------------------------------------------------
#Functions
	function_name parameter1 parameter2 etc = operations
function definitions don't have to be in a linear order, can't begin with uppercase letters
separate the function name from the parameter with a space
	#Successor function
	takes anything that has a defined successor, returns successor. 
		ghci> succ 8  ->9
#With several parameters
	#Min and max function
	min max take two things that can be put in an order. min returns the lesser one and max the greater one.
		ghci> min 3.4 3.2  ->3.2  
		ghci> max 100 101  ->101   
#Infix function
functions that take two parameters can be called as an infix function to avoid confusion between parameters
	#div and mod function 
		div 92 10 		-> 9 	#infix function is below
		92 `div` 10		-> 9 	#surround it with `` (below ~) NOT ''.
#Parentheses in function
	bar (bar 3) means: call bar with 3 as parameter, return result, call bar again with that result; not that bar is called with bar and 3 as parameters
	In C, that would be something like bar(bar(3))

#-------------------------------------------------------------------------------------
#Conditional
conditional is an expression in Haskell; the else part is mandatory in Haskell
Because the else is mandatory, an if statement will always return something and that's why it's an expression
	#Multiple line
	doubleSmallNumber x = if x > 100  
							then x  
							else x*2   
	#Single line
	doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  #a different function with + 1

#-------------------------------------------------------------------------------------
#Lists
	In Haskell, lists are a homogenous data structure. we can't have a list that has more than one type of data.
		ghci> let lostNumbers = [4,8,15,16,23,42]  
	[1,2,3] is actually just 1:2:3:[]. [] is an empty list
	strings are lists, we can use list functions on them
	#Appending/Combining lists
	putting something at the end of a list
		ghci> [1] ++ [2,3]  			->	[1,2,3]  
		ghci> "sup" ++ " " ++ "bro" 	->	"sup bro"  
		ghci> ['w','o'] ++ ['o','t']  	->	"woot"  
	#Prepending lists
	putting something at the beginning of a list
		ghci> 'A':" SMALL CAT"  ->		"A SMALL CAT"  
		ghci> 5:[1,2]  			->		[5,1,2]
	#Access an element by index
		ghci> "Steve Buscemi" !! 6  			->		'B'  
		ghci> [[1,2],[3,4]]	!! 0 !! 1			->		2
	Lists can contain another lists		e.g. [[],[],[1,2]]
	The lists within a list can be of different lengths but can't be of different types
	#Comparing lists
	Lists can be compared if they elements is comparable. list are compared in lexicographical order. 
	First the heads are compared. If equal, the second elements are compared, etc.
		ghci> [3,2,1] > [2,100,1010]  ->	True  
#Basic list functions: takes a list / lists and then
	#Head:
		ghci> head [5,4,3,2,1]  ->	5   
	#Tail: chops off head
		ghci> tail [5,4,3,2,1]  ->	[4,3,2,1]   
	#Last
		ghci> last [5,4,3,2,1]  ->	1   
	#Init
		ghci> init [5,4,3,2,1]  ->	[5,4,3,2]   
	#Length
		ghci> length [5,4,3,2,1]  ->	5  
	#Null 
		ghci> null [1,2,3]  ->	False  
		ghci> null []  		->	True
	#Reverse
		ghci> reverse [3,2,1]  ->	[1,2,3]  
	#Take
	takes number and a list. extracts that many elements from the beginning of the list.
		ghci> take 3 [5,4,3,2,1]  ->	[5,4,3]  
	take more elements than there are in the list, get original list. take 0 elements, get an empty list.
	#Drop 
	similar to take, only it drops the number of elements from the beginning of a list.
		ghci> drop 3 [8,4,2,1,5,6]  ->	[1,5,6]  
	#Maximum, minimum, sum, and product
		ghci> minimum [8,4,2,1,5,6]  ->	1  
		ghci> maximum [1,9,2,3,4]  	 ->	9   
		ghci> sum [5,2,1,6,3,2,5,7]  ->	31  
		ghci> product [6,2,1,2]  	->	24  
	#Elem
	check if a thing is an element of a list
		ghci> 4 `elem` [3,4,5,6]  ->		True  

#Ranges
	ghci> ['a'..'z'] 	-> "abcdefghijklmnopqrstuvwxyz"  
	ghci> ['K'..'Z']	-> "KLMNOPQRSTUVWXYZ"   
	ghci> [2,4..10] 	-> [2,4,6,8,10]    				#with step
	ghci> [5,4..1]		-> [5,4,3,2,1]					#negative step
ranges with steps limitation: You can't do [1,2,4,8,16..100] and expect to get all the powers of 2. 
	you can only specify one step and some non-arithmetic sequences are ambiguous if given only by a few of their first terms
Watch out when using floating point numbers in ranges since they are not completely precise (by definition)
	ghci> [0.1, 0.3 .. 1]  ->	[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  
You can use ranges to make infinite lists by not specifying an upper limit. 
		take 24 [13,26..]	#	get the first 24 multiples of 13 
	Haskell won't evaluate the infinite list immediately because it would never finish
	It'll wait to see what you want to get out of that infinite lists. here it sees you just want the first 24 elements and it gladly obliges.

#A handful of functions that produce infinite lists:
	#Cycle
	takes a list and cycles it into an infinite list.
		ghci> take 10 (cycle [1,2,3])  ->	[1,2,3,1,2,3,1,2,3,1]  
		ghci> take 12 (cycle "LOL ")   ->	"LOL LOL LOL "   
	#Repeat
	takes an element and produces an infinite list of just that element. It's cycling a list with only one element.
		ghci> take 10 (repeat 5)  ->	[5,5,5,5,5,5,5,5,5,5]  
	Although it's simpler to just use the replicate function if you want some number of the same element in a list. 
		ghci> replicate 3 10 returns ->	[10,10,10]

#List comprehension
  ghci> [x*2 | x <- [1..10], x*2 >= 12]  -> [12,14,16,18,20]  
  x (variable), x*2 (output function), x <- [1..10] (input set), x*2 >= 12 (predicate/condition)
  filtering: weeding out lists by predicates
  lists can be compared with each other if their components can be compared
	#Adding conditional
		ghci> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]   
		ghci> boomBangs [7..13]  ->	["BOOM!","BOOM!","BANG!","BANG!"]   
	  The function odd returns True on an odd number and False on an even one. 
	  The element is included in the list only if all the predicates evaluate to True.
	#Multiple predicates
	  If we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we'd do:
		ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]  ->	[10,11,12,14,16,17,18,20]  
	#Multiple input
		ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]  ->	[55,80,100,110] 
	#Placeholder
		length' xs = sum [1 | _ <- xs]   #replaces every element of a list with 1 and then sums that up
	 _ is a placeholder. instead of writing a variable name that we'll never use, we just write _ 
	#With `elem`
		removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   #takes a string and removes everything except uppercase letters
	#Nested list comprehensions
		ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]  
		ghci> [ [ x | x <- xs, even x ] | xs <- xxs]  ->	[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]  
	If you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.

#-------------------------------------------------------------------------------------
#Tuple
  can be heterogeneous
  a tuple list must have the same type config
    ghci> let x=[(1,"la"),(2,3)]				->		ERROR!!!
	ghci> let x=[(1,2),(8,11,5),(4,5)]		->		ERROR!!!
  tuples can contain lists with the same type config; don't have to have the same length
	ghci> let ye=[	([1,2],["a","b"]),		#tuple 1
					([3],["c"])				#tuple 2	]
  tuples can be compared with each other if their components is comparable
	#Pair tuple's fst and snd function
	fst takes a pair, returns first component. snd returns second component
		ghci> fst (8,11)  ->	8  
		ghci> snd (8,11)  ->	11  
	#Zip function
	takes TWO lists (can be heterogeneous), zips them together into one by joining matching elements into pairs
	  	ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]  ->	[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
	  when the length doesn't match:
		ghci> zip [5,3,2,6] ["im","a","turtle"]  	->	[(5,"im"),(3,"a"),(2,"turtle")]  
		ghci> zip [1..] ["a", "b", "c", "d"]  		->	[(1,"a"),(2,"b"),(3,"c"),(4,"d")]  

#-------------------------------------------------------------------------------------
Haskell has type inference. 
we don't have to explicitly write out the types of our functions and expressions

#Check type of a data
	ghci> :t data  ->	data :: data type 	e.g.Char, [Char], Bool, (Bool, Char)
	  :: means has/have type of

#Functions explicit type declaration
	removeNonUppercase :: [Char] -> [Char]  						#[Char] is replaceable by String
	removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   
  #Multiple parameter function
	addThree :: Integer -> Integer -> Integer -> Integer
	addThree x y z = x + y + z  

#Data Types
	#Int vs Integer
		Int is bounded (have min and max value) but more efficient. Integer is not bounded.
	#Float vs Double
			circumference :: Float -> Float  	#real floating point with single precision
			circumference r = 2 * pi * r  
			ghci> circumference 4.0  			->		25.132742  
			circumference' :: Double -> Double  #real floating point with double the precision
			circumference' r = 2 * pi * r  
			ghci> circumference' 4.0  			->		25.132741228718345  
	#Bool 
		a boolean type. can have only two values: True and False.
	#Char 
		represents a character. denoted by single quotes ''. A list of characters is a string.
	#Tuples 
		dependent on their length as well as the types of their components
		there is theoretically an infinite number of tuple types
		Note that the empty tuple () is also a type which can only have a single value: ()

#Check data type and type signature
	ghci> :t fst  
	fst :: (a, b) -> a  
  #Check operators data type and type signature
	ghci> :t (==)  
	(==) :: (Eq a) => a -> a -> Bool 	#takes any two values of the same type, returns a Bool.
		The type of those two values must be a member of the Eq class (class constraint).
	Note: pretty much all operators is a function. 
		a function comprised only of special characters, is considered an infix function by default. 
		Examining operators type: pass it to another function or call it as a prefix function, surround it in parentheses.
#Class constraint: everything before the => symbol
	Multiple class constraints:
		fromIntegral :: (Num b, Integral a) => a -> b. 
	the class constraints are separated by commas inside the parentheses.

#Type variables
a and b are not types, they're type variables. they can be of any types.
different type variables may or may not have different types
Polymorphic functions: functions that have type variables, so it can be different types on different occasion

#Typeclasses
a sort of interface that defines some behavior. 
If a type is a part of a typeclass, then it inherits the behaviour of the typeclass.
	
#Basic typeclasses
	#Eq
		Any type that support equality testing is a member of the Eq class. 
		All standard Haskell types except for I/O and functions are a part of the Eq typeclass.
		If there's an Eq class constraint for a type variable in a function, it uses == or /= somewhere inside its definition. 
	#Ord 
		is for types that have an ordering
			ghci> :t (>)  
			(>) :: (Ord a) => a -> a -> Bool  
		Ord covers all the standard comparing functions such as >, <, >= and <=. 
		The compare function takes two Ord members of the same type and returns an ordering. 
		Ordering is a type that can be GT (greater than), LT(lesser than) or EQ (equal)
		To be a member of Ord, a type must be a member of Eq.
			ghci> "Abrakadabra" `compare` "Zebra"  		->		LT  
	#Show
		Members of Show can be presented as strings. 
		The most used function that deals with the Show typeclass is show. 
			ghci> show 3  ->	"3"  	#takes a value whose type is a member of Show and presents it to us as a string
	#Read 
		the opposite typeclass of Show. 
		The read function takes a string and returns a type which is a member of Read.
			ghci> read "4"	-> exception error			#because of ambiguous type (read is polymorphic). it doesn't know what we want in return
			ghci> read "True" || False  	->	True	#not ambiguous because we did something with the result afterwards; GHCI could infer the result type
	  #Using explicit type annotations to clear ambiguity
		Type annotations: a way of explicitly saying what the type of an expression should be. 
			ghci> (read "5" :: Float) * 4  			->		20.0  
			ghci> read "[1,2,3,4]" :: [Int]  		->		[1,2,3,4]  
			ghci> read "(3, 'a')" :: (Int, Char)  	->		(3, 'a')  
		Haskell is statically typed, it has to know all the types before the code is compiled or evaluated. 
	#Enum
		members are sequentially ordered types (can be enumerated). we can use its types in list ranges. 
		have defined successors and predecesors, which you can get with the succ and pred functions. 
		Types in this class: ()/tuple, Bool, Char, Ordering (LT,ET,GT), Int, Integer, Float and Double.
	#Bounded 
		members have an upper and a lower bound.
			ghci> minBound :: Char 				->	'\NUL'  
			ghci> maxBound :: (Bool, Int, Char) ->	(True, 2147483647, '\1114111')  	#all tuples are also part of Bounded if the components are also in it
		minBound and maxBound have a type of (Bounded a) => a. they are polymorphic constants.
	#Num (numeric typeclass)
		members have the property of being able to act like numbers.
			ghci> :t 20  ->		20 :: (Num t) => t  
		whole numbers are polymorphic constants. They can act like any type that's a member of the Num typeclass.
		member of the Num typeclass: Int, Integer, Float, Double, etc
		To join Num, a type must be a member of Show and Eq.
	#Integral (numeric typeclass)
		Num includes all numbers: real numbers and integral numbers
		Integral includes only integral (whole) numbers. In this typeclass are Int and Integer.
	#Floating 
		includes only floating point numbers: Float and Double
		
#fromIntegral function
		fromIntegral :: (Num b, Integral a) => a -> b 	#takes an integral number, turns it into a more general number
		fromIntegral (length [1,2,3,4]) + 3.2		#delete the fromIntegral and you'll get an error of adding Int (length) with Float (3.2)

#-------------------------------------------------------------------------------------
