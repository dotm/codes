package main
import "fmt"
func main() {
    fmt.Println("Hello, 世界")
}

#--------------------------------------------------------------------------------
// single line comment
/* multi line comment */

#--------------------------------------------------------------------------------
#Print string
    #basic: fmt.Print("hello world", "!")
    #with new line: fmt.Println("hello world", "!")
    #formatted:
        fmt.Printf("%v %v %v %q", integer_value, float_value, boolean_value, string_value)
        fmt.Printf("the value %v has type %T", value, value)

#Print into io.Writer interface (stream)
    #basic: fmt.Fprint(os.Stdout, "hello world", "!")
    #with new line: fmt.Fprintln(os.Stderr, "hello world", "!")
    #formatted: fmt.Fprintf(CustomStream, "%d", integer_value)

#Output string
    #basic: fmt.Sprint("hello world", "!")
    #with new line: fmt.Sprintln("hello world", "!")
    #formatted: fmt.Sprintf("%d", integer_value)


#Format Specifiers
    numeric formats such as %d do not take flags for signedness or size
        instead, the printing routines use the type of the argument to decide these properties
            var x uint64 = 1<<64 - 1
            fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
            //will print 18446744073709551615 ffffffffffffffff; -1 -1
    the default conversion specifier %v produce exactly what Print and Println would produce
    when printing a struct, the modified format %+v
        annotates the fields of the structure with their names
            fmt.Printf("%v\n", vector)      //will print &{3 -1}
            fmt.Printf("%+v\n", vector)     //will print &{x: 3, y: -1}
    for any value the alternate format %#v
        prints the value in full Go syntax
            fmt.Printf("%#v\n", vector)     //will print &main.Vector{x: 3, y: -1}
    the quoted string format is available through %q
        when applied to a value of type string or []byte
    the %q format also applies to integers and runes,
        producing a single-quoted rune constant.
    the alternate format %#q will use backquotes on type string instead if possible
    the %x works on strings, byte arrays and byte slices as well as on integers,
        generating a long hexadecimal string,
        and with a space in the format (% x) it puts spaces between the bytes.
    prints the type of a value with %T

#Default format for custom type
        func (t *type_name) String() string {
            return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
        }
    If you need to print values of type type_name as well as pointers to type_name,
        the receiver for String must be of value type;
        the example above used a pointer because that's more efficient and idiomatic for struct types.
    Beware of infinite recursion when defining default format for custom type
        func (m MyString) String() string {
            return fmt.Sprintf("MyString=%s", m)            // Error: will recur forever.
        }
        func (m MyString) String() string {
            return fmt.Sprintf("MyString=%s", string(m))    // OK: note the conversion.
        }

#--------------------------------------------------------------------------------
#Variable declaration:
    var variableName = value
    var variableName variable_type
    var variableName variable_type = value
#Short assignment statement for variable
        func main() { k := 3 }
    Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type.

#Constant declaration
    const constantName = value
    const constantName constant_type
    const constantName constant_type = value

#--------------------------------------------------------------------------------
#Data types
    #Boolean: bool
        true false
    #Integers:
            int    int8    int16    int32    int64
            uint uint8 uint16 uint32 uint64
            uintptr
            byte        // alias for uint8
            rune        // alias for int32; represents a Unicode code point
        int, uint, and uintptr are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems
    #Float: float32 float64
    #Complex number: complex64 complex128
        Go will default to complex128 for a complex number literal in 64-bit systems
    #Pointer: *value_type
    #string
    #nil
#Zero values
    Variables declared without an explicit initial value are given their zero value:
        Numeric types   : 0
        Boolean type    : false
        String type     : ""
        Pointer         : nil
        Slice           : nil
        Map             : nil
        Channel         : nil
    Struct with omitted fields will have its omitted fields initialized to their respective types' zero values

#Type conversion: type(value)
    var a float64 = 3.8
    var b int = int(a)    //b is 3

#--------------------------------------------------------------------------------
#Data Allocation

#Using new: var variableName *type_name = new(type_name)
    new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T
    it returns a pointer to a newly allocated zero value of type T
    when you define a new data structure, make sure you can use new on it without further initialization
        i.e. it must be ready to use without setting things like this: customDataStructure.property = zero_value
#new and composite literal
    new(structName) is equal to &structName{}

#Using make: var variableName type_name = make(type_name, arguments)
    can only be used to create slices, maps, and channels
    returns an initialized (not zeroed) value of type_name
        we'll get nil value if we use new(T) with slices, maps, and channels
    unlike new(T), make doesn't return a pointer of the type

#--------------------------------------------------------------------------------
#Pointer
        pointer holds the memory address of a value
        Go has no pointer arithmetic
    #declaration: var p *int
    #create pointer: p = &integerVariable
    #dereferencing/indirecting pointer:
        fmt.Println(*p)     // read i through the pointer p
        *p = 21             // set i through the pointer p
    #access struct field through pointer
        (*p).structField
        p.structField       //shorthand

#--------------------------------------------------------------------------------
#Struct: a collection of fields
    #declaration:
        type structName struct {
            fieldName1 field_type
            fieldName2 field_type
            fieldName3 field_type
        }
    #create using composite literal:
        var structVariable = structName{value, value, value}
        var structVariable = structName{fieldName1: value, fieldName2: value}     //partial initialization permitted
        var structVariable = structName{fieldName2: value, fieldName1: value}     //unordered initialization permitted
        var structVariable = structName{}                                         //all struct field set to zero value
    #access field: structVariable.fieldName1

#--------------------------------------------------------------------------------
#Array
        (zero index, homogeneous, fixed-length)
        value type (pass by value)
            assigning one array to another copies all the elements
            passing an array to a function will copy it (and not passing the reference)
        the size of an array is part of its type
            types [10]int and [20]int are distinct
        they are a building block for slices
            array's value property can be useful but also expensive
            if you want efficiency, you can pass a pointer to the array
            but that style isn't idiomatic; use slices instead
        unless the dimensions (length) of an array is fixed, use slices
    #create array with zero values
        var arrayName [length]value_type
        var a [10]int     //initialized to zero values
    #create using composite literal:
        var arrayName [length]value_type = [length] value_type {value, value}
        var arrayName [length]value_type = [length] value_type {index: value, index: value}
        var a [10]int = [10]int{11,22}
        var a [10]int = [10]int{2: 22, 5: 55}
    #access element by index: array[index]
    #change element value at index: array[index] = value

#Slices:
        value type (pass by value)
        a run-time data structure that have 3 fields:
            length: the number of elements the slice currently hold
            capacity: the number of elements in the underlying array, counting from the first element in the slice
            a pointer to its underlying array
        if you assign one slice to another, both will refer to the same array
        a proxy to its underlying array
            changing the elements of a slice
            modifies the corresponding elements of its underlying array
            and other entities can see the change
        a nil slice has a length and capacity of 0 and has no underlying array.
        slices can contain any type, including other slices.
    #create
        #from array:
            var sliceName []value_type = arrayName[upper_index : lower_index]
            var sliceName []value_type = arrayName[1:3]     //will include elements of index 1 and 2 from arrayName
            var sliceName []value_type = arrayName[1:]    //will include elements from index 1 until the last element from arrayName
            var sliceName []value_type = arrayName[:3]    //will include elements of index 0, 1, and 2 from arrayName
            var sliceName []value_type = arrayName[:]     //will include all elements from arrayName
        #slice literal: []bool{true, true, false}
            this creates the array [3]bool{true, true, false}
            then builds a slice that references it
        #using make function to allocate a zeroed array and returns a slice that refers to that array:
            make([]slice_type, length)                //capacity == length
            make([]slice_type, length, capacity)
            b := make([]int, 0, 5)                    // len(b)=0, cap(b)=5
    #reslicing:
        sliceName = sliceName[new_upper_index : new_lower_index]
    #change underlying array:
        sliceName = arrayName[upper_index : lower_index]
    #get slice length: len(sliceName)
    #get slice capacity: cap(sliceName)
    #append value: sliceName = append(sliceName, value, value, ...)

#Two-dimensional slices
    To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices
        type Transform [3][3]float64    // A 3x3 array, really an array of arrays.
        type LinesOfText [][]byte         // A slice of byte slices.
    Because slices are variable-length, it is possible to have each inner slice be a different length.

#--------------------------------------------------------------------------------
#Map: maps keys to values
        pass by reference
        a nil map has no keys, nor can keys be added
        the key can be of any type for which the equality operator is defined:
            integers, floating point, complex numbers, strings,
            interfaces (as long as the dynamic type supports equality),
            pointers, structs, arrays
    #create
        #using make to create empty map:
            mapName := make(map [key_type] value_type)     //e.g. make(map[string]int)
        #using composite literal:
            mapName := map[key_type]value_type {
                keyName: value,
                keyName: value,
            }
    #access element by key: map[keyName]
    #add value to key: map[keyName] = value
    #change value by key: map[keyName] = value
    #delete element by key: delete(map, keyName)
    #check if an element exist at a key:
        elem, isExist := map[keyName]             //if no element found at keyName, isExist will be false and elem will be zero-valued
        _, isExist := map[keyName]

#Set
    A set can be implemented as a map with value type bool
        set := map[string]bool{"uuid": true, "uuid": true}

#--------------------------------------------------------------------------------
Conditional

#If statement
    if condition {
        statements
    } else if condition {
        statements
    } else {
        statements
    }
#If statement with init_statement: if init_statement; condition { statements }
    variables declared in init_statement are available only inside the if statement
    the else if and else statement can access variables from the if init_statement
        but they can't have an the init_statement

#Switch statement
        doesn't fallthrough (break is inserted automatically at the end of each case)
        can use init_statement after the switch keyword (just like if statement)
        can be used without init_statement and expression (used as an if statement)
    switch init_statement; expression {
        case condition:
            statements
        case condition, condition, condition:
            statements
        default:
            statements
    }
#break

#Type switch statement
        var value interface{}
        value = functionOfSomeType()
        switch t := value.(type) {
        default:
            fmt.Printf("unexpected type %T\n", t) // %T prints whatever type t has
        case bool:
            fmt.Printf("boolean %t\n", t) // t has type bool
        case int:
            fmt.Printf("integer %d\n", t) // t has type int
        case *bool:
            fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
        case *int:
            fmt.Printf("pointer to integer %d\n", *t) // t has type *int
        }

#--------------------------------------------------------------------------------
Loop

#For loop
    for i := 0; i < 3; i++ { statements }
    for init_statement; condition_expression; post_statement { statements }
        the init_statement and post_statement is optional:
            for ; condition_expression ; { statements }
            for condition_expression { statements }            //the ; can be omitted if only the condition_expression exist
        variables declared in init_statement are available only inside the loop
#Infinite loop: for { break }     //use break to stop the loop
#While loop: for condition_expression { statements }
#break
#continue

#Label
    label:
    for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
            if j > 3 { break }
            if i > 3 { break label }
            fmt.Println(i, j)
        }
    }

#Iterate over array, string, and slice using range
    for index, value := range sliceName { statements }
    for index := range sliceName { statements }            //capture index only
    for _, value := range sliceName { statements }         //capture value only
    for range sliceName { statements }                     //without capturing index or value

#Iterate over map using range
    for key, value := range mapName { statements }
    for key := range mapName { statements }            //capture index only
    for _, value := range mapName { statements }         //capture value only
    for range mapName { statements }                     //without capturing index or value

#--------------------------------------------------------------------------------
#Function
        first-class object
    #definition
        #basic: func functionName() { function_body }
        #with parameters: func functionName(parameterName parameter_type, parameterName parameter_type) { function_body }
            When consecutive parameters share a type, you can omit the type from all but the last.
                func add(x, y int, z string) { function_body }
        #with return value: func functionName() return_type { return value }
        #with multiple return value: func functionName() (return_type, return_type) { return value, value }
        #with named return value:
                func functionName() (returnName return_type) { return value }
                func split(sum int) (x, y int) {
                    x = sum / 2
                    y = sum - x
                    return            // this will return the latest value of x and y
                }
            the named return values are treated as variables defined at the top of the function
                use them for documentation purposes
        #anonymous function: ???
            func (){ function_body }
            func (){ function_body }()    //automatically run the function
    #higher-order function:
        func functionName
            (callback func(parameter_type,parameter_type) return_type)    //take a callback function as argument
            func(parameter_type,parameter_type) return_type             //return a function as closure
            { function_body }
    
#Method
        Go doesn't have classes. But, you can define methods on types.
        A method is a function with a special receiver argument.
        The receiver argument can be of type parameter_type or a pointer to parameter_type
            Go will resolve the pointer automatically
    #definition:
        func (receiverArgumentName type) methodName(parameterName parameter_type) return_type { function_body }
        func (v Vertex) Abs() float64 { statements }
    #call: variableName.methodName(argument, argument)
    #add method for types defined in different package (e.g. built-in types):
        type MyInt int                        //use type alias
        func (x MyInt) square() int {         //declare the method on the type alias
            return int(x*x)                 //do type casting to original type if you want to
        }     
        a := MyInt(-2)                        //convert the original type into the type alias
        a.square()                            //use the method (convert it back to the original type if necessary)
#Method with pointer receiver
        type Vertex struct {X, Y float64}
        func (v *Vertex) Scale(f float64) { //if you don't use the * and declare the receiver as pointer,
            v.X = v.X * f                     //the two lines here won't work
            v.Y = v.Y * f                     //it wont modify the original vertex
        }                                     //hence calling vertex.Scale(2) won't work
    There are two reasons to use a pointer receiver:
        so that the method can modify the value that its receiver points to
        to avoid copying the value on each method call (which can impact efficiency if the value is a large struct)
    All methods on a given type should have either value or pointer receivers, but not both

#Defer statement
        func a() int {
            a := 1
            defer fmt.Println(a)    //call defer right before return if possible
            return a
        }
        func main() {
            defer fmt.Println("world")
            fmt.Println("hello")
        }
        func functionName() {
            file, err := os.Open(filename)
            if err != nil {
                return "", err
            }
            defer file.Close()        // call defer close to the definition of file
        }
    A defer statement defers the execution of a function until the surrounding function returns.
    The deferred call's arguments are evaluated immediately,
        but the function call is not executed until the surrounding function returns.
    Deferred function calls are pushed onto a stack.
        When a function returns, its deferred calls are executed in last-in-first-out order.

#--------------------------------------------------------------------------------
#Interface
    interface type is a set of method signatures
        type interfaceName interface {
            method signature
            method signature
        }
        type Absolutable interface { Abs() float64 }
    A type implements an interface simply by implementing its methods (no implements keyword necessary)
#Nil underlying value
    If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.
        var i interfaceName
        var t *type_name
        i = t
        func (t *T) M() { return t == nil }     //this will return true because the underlying value t is nil
    An interface value that holds a nil concrete value is itself non-nil.
#Nil interface
    A nil interface value holds neither value nor concrete type.
        var i interfaceName
        i == nil                //true
    calling a method of a nil interface causes runtime error, unlike calling a method with nil underlying value
        this is because you can handle the nil underlying value inside the function
        e.g. by using a guard like: if t == nil {do something}
#Empty interface
    is interface type with zero method signature
    may hold values of any type
    are used by code that handles values of unknown type
#Type assertions
    provides access to an interface value's underlying concrete value
        var i interface{} = "Hello"
        s := i.(string)                 //s == "Hello"
        s, ok := i.(string)             //s == "Hello"; ok == true
        f, ok := i.(float64)            //f == 0; ok == false
        f = i.(float64)                 //panic
#Type switches
    switch value := interfaceName.(type) {
    case int:
        value += 1        // here value has type int
    case string:
        value += " "    // here value has type string
    default:
        // no match; here value has the same type as interfaceName
    }

#fmt.Stringer interface: for types that can describe itself as a string
    type Stringer interface {
        String() string
    }
    type Person struct { Name string; Age int }
    func (p Person) String() string {
        return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
    }

#Error interface - go programs express error state with error values
    type error interface {
        Error() string
    }
#Conforming to error interface
    type MyError struct { When time.Time; What string }
    func (e *MyError) Error() string {
        return fmt.Sprintf("at %v, %s", e.When, e.What)
    }
    func run() error {
        return &MyError{time.Now(), "unknown error encountered",}
    }
#Guarding against error
    func main() {
        if err := run(); err != nil { fmt.Println(err) }
        
        i, err := strconv.Atoi("42")
        if err != nil     { fmt.Printf("couldn't convert number: %v\n", err) }
        else            { fmt.Println(i) }
    }

#--------------------------------------------------------------------------------
#Exporting
    In Go, a name is exported if it begins with a capital letter.

#Import statement
    import "fmt"
    import "math"
#Factored import statement
    import (
        "fmt"
        "math"
    )

#--------------------------------------------------------------------------------
#Concurrency

#Goroutine: a lightweight thread managed by the Go runtime
    go f(x, y, z)
        starts a new goroutine running f
        The evaluation of f, x, y, and z happens in the current goroutine
        the execution of f happens in the new goroutine
    Goroutines run in the same address space,
        so access to shared memory must be synchronized

#Channel
        a typed conduit through which you can send and receive values with the channel operator <-
        first-in-first-out (queue)
        By default, sends and receives block until the other side is ready.
            This allows goroutines to synchronize without explicit locks or condition variables.
         Only the sender should close a channel, never the receiver.
         Sending on a closed channel will cause a panic.
    #create: channelName := make(chan type_name)
    #send value to channel: channelName <- value
    #receive value from channel: variableName := <- channelName
    #close channel (from sending value): close(channelName)
    #check if channel is closed: variableName, stillOpen := <-ch
        stillOpen will be false if the channel is closed
#Example usage of channel and goroutine
    func functionName(ch chan int){ ch <- 1; ch <- 2; close(ch) }
    func main() {
        ch := make(chan int)
        go functionName(ch)
        
        fmt.Println(<-ch)         //print 1
        fmt.Println(<-ch)         //print 2
        fmt.Println(<-ch)         //print 0 since channel is closed; will raise fatal error if channel is not closed
    }

#Buffered Channel: channel that can be filled by value from the same goroutine
    channelName := make(chan type_name, buffer_length)
    ch := make(chan int, 100)
#Example usage of buffered channel
    ch := make(chan int, 2)
    ch <- 1; ch <- 2
    ch <- 3             //overflowing the buffer causes fatal error
    fmt.Println(<-ch)
    fmt.Println(<-ch)

#Iterate over a channel (until it is closed)
    for value := range channelName { fmt.Println(value) }

#Select statement
    lets a goroutine wait on multiple communication operations
    select blocks until one of its cases can run, then it executes that case
        It chooses one at random if multiple are ready
    The default case in a select is run if no other case is ready.
        Use a default case to try a send or receive without blocking:
#Example
    func functionName(firstChannel, secondChannel chan int){
        select {
            case variableName := <- firstChannel: fmt.Printf("firstChannel: %v\n", variableName)
            case <- secondChannel:                 fmt.Println("received signal from secondChannel")
        }
    }
    func main(){
        a := make(chan int); b := make(chan int);
        go functionName(a,b)
        a <- 1
    }
#Example with default case
    func main() {
        boom := time.After(3 * time.Second)
        for {
            select {
            case <-boom:
                fmt.Println("BOOM!")
                return
            default:
                fmt.Println("tick")
                time.Sleep(1 * time.Second)
            }
        }
    }

#sync.Mutex
    channels are great for communication among goroutines
    What if we just want to make sure
        only one goroutine can access a variable at a time to avoid conflicts?
        this concept is called mutual exclusion
        the conventional name for the data structure that provides it is mutex
#Example usage
    type SafeCounter struct { // is safe to use concurrently
        v int; mux sync.Mutex;
    }
    func (c *SafeCounter) Increment() {
        fmt.Println("Function called")
        c.mux.Lock();                 fmt.Println("Lock so only one goroutine at a time can access c.v");
        time.Sleep(time.Second);
        c.v++;                        fmt.Printf("Counter changed to %v\n", c.v);
        c.mux.Unlock();             fmt.Println("Release lock");
    }
    func (c *SafeCounter) Value() int {
        c.mux.Lock()
        // Lock so only one goroutine at a time can access the map c.v.
        defer c.mux.Unlock()
        return c.v                    //returns the current value of the counter
    }
    func main() {
        c := SafeCounter{v: 0}
        for i := 0; i < 3; i++ { go c.Increment() }
        time.Sleep(time.Second * 5)
        fmt.Println(c.Value())
    }
