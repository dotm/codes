Haskell is statically typed (with automatic type inference).
Whitespace matters in Haskell

You can use tab completion in GHCi
  You can see all function using tab completion (in an empty command line, press tab, press y to display all possibilities)

  :{ GHCi multiline command :}
#Comment
  {- A multiline comment  -}
  -- a single line comment

#Loading function(module):
  !file_name.hs
  $ :l file_name
#Reload function:
  :r (or just repeat :l file_name)

#Let keyword
Doing let a = 1 inside GHCi is equivalent of writing a = 1 in a script and then loading it.
let can NOT be used when using copmiler

#-------------------------------------------------------------------------------------
#Operators
  pretty much all operators is a function.
  if a function is comprised only of special characters (like == operator),
    it is considered an infix function by default.
  if we want to examine the type of such function, pass it to another function or call it as a prefix function,
    we have to surround it in parentheses: (+) 1 2 -> 3
    
#Arithmetic operators: + - * / div mod ^
#Comparators: == /= <= >= < >
#Boolean operators: && || not
  #Boolean data type: True False

#-------------------------------------------------------------------------------------
#Functions
  function can't begin with uppercase letter
  single quotes (') is a valid character (you can use it in function_name)
  a function has no side-effects
    function can only calculate something and return it as a result
  every expression and function must return something
#Assertion of Equivalence (Definition/Name/Constant)
    myName = "Yoshua"
  a definition (or a name) is a function that
    doesn't take any parameters and always return the same value

#Definition
    name = value
  #define string using double quotes: myName = "Yoshua"
  #define character using single quotes: a = 'a'
  
#Function definition (in Haskell source file)
  function_name parameter1 parameter2 = statements
    e.g. add x y = x+y
#Function definition (in GHCi interpreter)
  let function_name parameter1 parameter2 = statements
#Function call/application
  function_name parameter1 parameter2
  (function_name parameter1 parameter2) #you can put () around function call to make it clearer
#Infix function
  functions with 2 parameters can be called and defined as infix function using backticks to avoid confusion between parameters
    div a b = function_body
      := a `div` b = function_body
    (div 92 10) := (92 `div` 10)

#-------------------------------------------------------------------------------------
#Conditional (if expression)
  the else part is mandatory,
    hence every conditional statements is also an expressions in Haskell
    (you'll always get a value whatever branch get executed)
  
#If expression
  #Multiple line
    doubleSmallNumber x =
      if x > 100
      then x
      else x*2
  #Single line
    doubleSmallNumber x = if x > 100 then x else x*2
    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  #a different function with + 1

#-------------------------------------------------------------------------------------
#Lists
  are a zero indexed, homogenous, variable-length data structure
  [1,2,3] is syntactic sugar for 1:2:3:[]
    [] is an empty list
  multi-dimensional list := nested list
  jagged multi-dimensional list is allowed
#Strings
  strings are lists, we can use list functions on them
  "hello" is just syntactic sugar for ['h','e','l','l','o']
#Ranges
  floating point range are not completely precise by definition (e.g. instead of 1, you may get 0.999)
  you can only specify arithmetic sequences (sequences with constant difference between terms) with range

#List (and String)
  #Definition: a = [1,2,3]
  #Appending lists
    [1] ++ [2,3]            ->  [1,2,3]
    ['w','o'] ++ ['o','t']  ->  "woot"
  #Prepending lists
    'A':" SMALL CAT"  ->    "A SMALL CAT"
    5:[1,2]        ->    [5,1,2]
  #String interpolation
    "length: " ++ show 3 ++ " elements"   -> "length: 3 elements"
  #Access element by index
    "Yoshua" !! 1      ->  'o'
    [[1,2],[3]]!!0!!1  ->  2    #accessing multi-dimensional list
  #Comparing lists
      [3,2,1] > [2,100,1010]  ->  True
    lists can be compared in lexicographical order if they elements is comparable

#Basic list (and String) functions:
  length    [5,4,3,2,1]     ->  5
  null      []              ->  True      #check if list is empty
  head      [5,4,3,2,1]     ->  5
  tail      [5,4,3,2,1]     ->  [4,3,2,1]
  last      [5,4,3,2,1]     ->  1
  init      [5,4,3,2,1]     ->  [5,4,3,2]
  reverse   [3,2,1]         ->  [1,2,3]
  take      3 [5,4,3,2,1]   ->  [5,4,3]
    #if you take more elements than there are in the list, you'll just get original list
    #if you take 0 elements, you'll get an empty list.
  drop      3 [8,4,2,1,5,6] ->  [1,5,6]
    #works just like take
  minimum   [8,4,2,1,5,6]   ->  1
  maximum   [1,9,2,3,4]     ->  9
  sum       [5,2,1]         ->  8
  product   [6,2,1,2]       ->  24
  4 `elem`  [3,4,5,6]       ->  True    #check if a thing is an element of a list
#zip function
  takes 2 lists (can be of different type), zips them together into a list of pairs:
    zip [1 .. 5] ["one", "two", "three", "four", "five"]  ->  [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
  when the length doesn't match:
    zip [1..] ["a", "b", "c", "d"]      ->  [(1,"a"),(2,"b"),(3,"c"),(4,"d")]
#zipWith function
    zipWith (+) [4,2,5,6] [2,6,2,3]    ->     [6,8,7,9]
  takes a function and two lists as parameters
    and joins the two lists by applying the function between corresponding elements
#Operation on nested list
  zipWith (zipWith (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]   ->    [[3,4,6],[9,20,30],[10,12,12]]
  map (map (^2)) [[1,2],[3,4,5,6],[7,8]]    ->    [[1,4],[9,16,25,36],[49,64]]

#Ranges
    [0..3]      -> [0,1,2,3]
    ['a'..'z']  -> "abcdefghijklmnopqrstuvwxyz"
    ['K'..'Z']  -> "KLMNOPQRSTUVWXYZ"
  #with step other than +1, you must specify the second element
    [5,4..1]    -> [5,4,3,2,1]  #negative (-1) step
    [2,4..10]   -> [2,4,6,8,10] #with +2 step
    ['a','j'..'z'] -> "ajs"

#Infinite list
  #with range
      take 24 [13,26..]  #get the first 24 multiples of 13
    Haskell won't evaluate the infinite list immediately (lazy evaluation).
  #with cycle
      take 10 (cycle [1,2,3])  ->  [1,2,3,1,2,3,1,2,3,1]
      take 12 (cycle "LOL ")   ->  "LOL LOL LOL "
  #with repeat
    a list cycle with only one element.
      take 10 (repeat 5)  ->  [5,5,5,5,5,5,5,5,5,5]

#-------------------------------------------------------------------------------------
#List comprehension
    in math, set comprehensions are normally used for building more specific sets out of general sets.
    in Haskell, list comprehensions are used for building more specific lists out of general lists.
#Nested list comprehensions
  nested list comprehensions are possible if you're operating on lists that contain lists.
  if you're not in GHCi, it's better to split longer list comprehensions across multiple lines.

#List comprehension
  #with input_set only
    [constant | input_set ]
    ['a' | x <- [1..3]] -> "aaa"
  #the _ placeholder
    instead of making a variable name that we'll never use (like x in the example above), we can just write _ as the variable
    ['a' | _ <- [1..3]] -> "aaa"
    [1 | _ <- [1..3]]   -> [1,1,1]
    length xs = sum [1 | _ <- xs]
  #with variable
    [variable | input_set ]
    [x | x <- ['a'..'e']] -> "abcde"
  #basic with output_function
    [output_function | input_set ]
    [x*2 | x <- [6..10]]  -> [12,14,16,18,20]
      x (variable), x*2 (output function), x <- [1..10] (input set)
  #filtering using predicate/condition
    [output_function | input_set, predicate]
    [output_function | input_set, predicate, predicate]
    [x*2 | x <- [1..10], x*2 >= 12]  -> [12,14,16,18,20]
  #multiple input
    [output_function | input_set, input_set]
    [output_function | input_set, input_set, predicate]
    [x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] ->  [55,80,100,110]
    [(x,y) | x <- [2,5,10], y <- [8,10,11]]         ->  [(2,8),(2,10),(2,11),(5,8),(5,10),(5,11),(10,8),(10,10),(10,11)]
  #conditional output_function
    [ if x < 10 then "BOOM!" else "BANG!" | x <- [7..13], odd x]  ->  ["BOOM!","BOOM!","BANG!","BANG!"]
  #with `elem` (is element of) in predicate
    [variable | input_set, variable `elem` a_list]    #include in the output only if it's an element of a_list
    removeNonUppercase string = [ c | c <- string, c `elem` ['A'..'Z']]
  #with pattern matching
    [output_function | pattern matching input_set ]
    [a+b | (a,b) <- [(1,3), (4,3), (2,4)]] -> [4,7,6]
  #with let binding
    [output_function | input_set, let binding, predicate]
    [bmi | (w, h) <- [(1,3), (4,3), (2,4)], let bmi = w / h ^ 2, bmi >= 25.0]
#Nested list comprehensions
  #basic
    [[output_function | variable <- inner_list_variable ] | inner_list_variable <- outer_list]
  #with predicate to filter the inner_list
    [[output_function | variable <- inner_list_variable, predicate ] | inner_list_variable <- outer_list]
  #with predicate to filter the outer_list
    [[output_function | variable <- inner_list_variable ] | inner_list_variable <- outer_list, predicate]

#-------------------------------------------------------------------------------------
#Tuple
    tuple_name = (element, element, ...)
  is a fixed-length and heterogeneous data structure
  tuples can be compared with each other if their components is comparable
  Use tuples instead of list when
    you know in advance how many components some piece of data should have
    you need heterogeneous data structure
  pair: tuple of size 2
  triple: tuple of size 3
#List of tuples
  must have the same type configuration (the tuple must be of the same size and each elements must be of the same type)
    let x=[(1,"la"),(2,3)]        ->    ERROR!!!
    let x=[(1,2),(8,11,5),(4,5)]  ->    ERROR!!!
  the tuples in a list of tuples can contain lists with different length but of the same type
    let x=[([1,2],["a","b"]),([3],["c"])]

#first and second function
    fst (8,11)  ->  8
    snd (8,11)  ->  11
  this will only work on pairs
    
#-------------------------------------------------------------------------------------
#Data Types
  #Int vs Integer: Int is bounded (have min and max value) but more efficient. Integer is not bounded.
  #Float vs Double: Double have more floating point precision than Float
  #Bool: True, False
  #Char (character) denoted by single quotes ''. 
    A list of characters is a string: [Char] := String
  #Tuples

#Type reflection from GHCi
  :t expression  ->  expression :: data type
    :t True
    :t (==)
  a::b means "a has/have type of b"

#Giving function an explicit type declaration/signature/annotation
    removeNonUppercase :: [Char] -> [Char]
    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
#Declaring type signature in GHCi using let and semicolon:
    let add :: Int -> Int -> Int; add x y = x + y
#Multiple parameter function type signature
    addThree :: Integer -> Integer -> Integer -> Integer
    addThree x y z = x + y + z
  The return type is the last item in the declaration and the parameters are the first three.
  Haskell use -> and not comma for multiple parameters because currying
    i.e. addThree :: Integer -> Integer -> Integer -> Integer
      := addThree :: Integer -> (Integer -> (Integer -> Integer))
    the parentheses are implied and so can be ignored
#function as parameter
    check :: (t -> Bool) -> t -> Bool
    check f x = if (f x) then True else False
  here the parentheses are necessary and so must be written (unlike with currying)
  
#Class constraint: everything before the => symbol
  odd :: Integral a => a -> Bool
  class constraint => type signature
#Multiple class constraints: fromIntegral :: (Num b, Integral a) => a -> b

#Type variables
    fst :: (a, b) -> a
  a and b here are not (explicit) types, they're type variables (they can be of any types)
  same type variable in the same signature must be of the same type
    i.e. in fst signature above, if a is Int in the input, it must also be Int in the output
  different type variables don't have to be of different types
    i.e. a and b can be of the same type as in: fst (1,2)
  type variable is much like generics, only much more powerful
    because it allows us to easily write very general functions
    if they don't use any specific behavior of the types in them.
#Polymorphism
  Polymorphic functions: functions that have type variables, so it can be different types on different occasion
  polymorphic constants: constants that can be of different types on different occasion

#Typeclass
  typeclass: a sort of interface that defines some behavior.
  If a type is a part of a typeclass, then it inherits the behaviour of the typeclass.

#Basic typeclasses
  #Eq: types that support equality testing
    all standard Haskell types except for I/O and functions are a part of the Eq typeclass.
    if there's an Eq class constraint for a type variable in a function, it uses == or /= somewhere inside its definition.
  #Ord: types that have an ordering
    Ordering is a type that can be GT (greater than), LT(lesser than) or EQ (equal)
    Ord covers all the standard comparing functions such as >, <, >= and <=.
      The compare function takes two Ord members of the same type and returns an ordering.
    to be a member of Ord, a type must also be a member of Eq.
  #Show: types that can be presented as strings.
    The most used function that deals with the Show typeclass is show.
      show 3 -> "3"   #takes a value whose type is a member of Show and presents it to us as a string
  #Read: types that can be read from strings.
    The read function takes a string and returns a type which is a member of Read.
      read "True" || False  ->  True  #not ambiguous because we did something with the result afterwards; GHCi could infer the result is Bool (not String)
      read "4" -> exception error     #ambiguous type; read doesn't know what type we want in return
    #Using type annotations with read to clear ambiguity
      Type annotations: a way of explicitly saying what the type of an expression should be using double semicolon (::)
        (read "5" :: Float) * 4        ->  20.0
        read "[1,2,3,4]" :: [Int]      ->  [1,2,3,4]
        read "(3, 'a')" :: (Int, Char) ->  (3, 'a')
      Haskell is statically typed, it has to know all the types before the code is compiled (or evaluated in GHCi).
  #Enum: sequentially ordered types (can be enumerated)
    we can use Enum types in ranges: [1..3]
    have defined successors and predecesors (which you can get with the succ and pred functions)
    types in this class: ()/tuple, Bool, Char, Ord, Int, Integer, Float and Double.
  #Bounded: types have an upper and a lower bound.
    minBound and maxBound have a type of (Bounded a) => a. they are polymorphic constants.
      minBound :: Char ->  '\NUL'
    all tuples are also part of Bounded if the components are also in it
      maxBound :: (Bool, Int, Char) ->  (True, 2147483647, '\1114111')
  #Num (numeric typeclass): types that have the property of being able to act like numbers.
      :t 20  ->  20 :: (Num t) => t
    numbers are polymorphic constants. they can act like any type that's a member of the Num typeclass.
    members of the Num typeclass: Int, Integer, Float, Double, etc
    to be a member of Num, a type must also be a member of Show and Eq.
    Num includes all numbers: real numbers and integral numbers
  #Floating (numeric typeclass): includes only floating point numbers (Float and Double)
  #Integral (numeric typeclass): includes only integral/whole numbers (Int and Integer)
    #fromIntegral function
      fromIntegral :: (Num b, Integral a) => a -> b   #takes an integral number, turns it into a more general number
      fromIntegral (length [1,2,3,4]) + 3.2           #delete fromIntegral and you'll get an error of adding Int (length) with Float (3.2)

#-------------------------------------------------------------------------------------
#Pattern matching
  pattern matching: specifying patterns to which some data should conform
    and then checking to see if it does and deconstructing the data according to those patterns.
  you can pattern match on any data type.
  when defining functions, you can define separate function bodies for different patterns
    the patterns will be checked from top to bottom
    and when it conforms to a pattern, the corresponding function body will be used.
  order is important when specifying patterns
    specify the most specific ones first (e.g. base case in recursion first to avoid infinite recursion)
    and then the more general ones later
    and the catch-all default case last (if you put the catch-all at the top, the patterns after it won't get executed)
  pattern matching can fail if we try to call it with an input that we didn't expect
    i.e. pattern will fail if we supply a data and it can't find any pattern that match the data
    we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input
#list pattern matching with as pattern
  the 'as pattern' is a handy way of
    breaking something up according to a pattern and binding it to names
    whilst still keeping a reference to the whole thing
    by putting a name and an @ in front of a pattern.
  we use as patterns to avoid repeating ourselves when matching against a bigger pattern
    when we have to use the whole thing again in the function body.
      e.g. the pattern xs@(x:y:ys) will match exactly the same thing as x:y:ys
        but you can easily get the whole list via xs
        instead of repeating yourself by typing out x:y:ys in the function body again.

#Pattern matching
  #basic pattern matching on parameters in function definitions
    sayMe :: (Integral a) => a -> String
    sayMe 1 = "One!"
    sayMe 2 = "Two!"
    sayMe 3 = "Three!"
    sayMe 4 = "Four!"
    sayMe 5 = "Five!"
    sayMe x = "Not between 1 and 5"       #without this catch-all pattern, sayMe 6 would return an error (the pattern matching will fail)
  #for recursion
    factorial :: (Integral a) => a -> a
    factorial 0 = 1
    factorial n = n * factorial (n - 1)
  #with tuple
    addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
    addVectors a b = (fst a + fst b, snd a + snd b)     #without pattern matching
    addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)   #with pattern matching (using only one catch-all pattern)
  #with list comprehension
    [a+b | (a,b) <- [(1,3), (4,3), (2,4)]] -> [4,7,6]   #the pattern specified here is (a,b)
  #with list
    #basic (x:xs) pattern
        head :: [a] -> a
        head [] = error "Can't call head on an empty list, dummy!"
        head (x:_) = x
      pattern like x:xs will bind the head of the list to x and the rest of it to xs,
        even if there's only one element so xs ends up being an empty list.
      if you want to bind to several variables
        (even if one of them is just _ and doesn't actually bind at all),
        we have to surround them in parentheses.
    #with recursion
        last :: [a] -> a
        last [] = error "empty list"
        last [x] = x                             #(x:[]) could be rewriten as [x]
        last (_:x) = last x
    #binding to more than two variable
        tell :: (Show a) => [a] -> String
        tell [] = "The list is empty"
        tell (x:[]) = "The list has one element: " ++ show x
        tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
        tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
      if you want to bind, say, the first three elements to variables
        and the rest of the list to another variable,
        you can use something like x:y:z:zs. 
          this will only match against lists that have 3 elements or more.
    #as patterns
        capital :: String -> String
        capital "" = "empty string!"
        capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

#-------------------------------------------------------------------------------------
#Guards
  guards are a way of testing whether some property of a value (or several of them) are True or False
    and then running the function body associated with the guard if it evaluates to True
  guards are a lot more readable than if expression when you have several conditions
    and they play really nicely with patterns.
  
#Guards
  #basic
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body   #otherwise always evaluate to True
    max' :: (Ord a) => a -> a -> a
    max' a b
      | a > b = a
      | otherwise = b
  #single line
    max' :: (Ord a) => a -> a -> a
    max' a b | a > b = a | otherwise = b
  #with where clause to bind local names
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body
      where
        name = value
        name = value
    bmiTell :: (RealFloat a) => a -> a -> String
    bmiTell weight height
      | bmi <= skinny = "You're underweight, you emo, you!"
      | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"
      | bmi <= fat = "You're fat! Lose some weight, fatty!"
      | otherwise = "You're a whale, congratulations!"
      where 
        bmi = weight / height ^ 2
        (skinny, normal, fat) = (18.5, 25.0, 30.0)

#-------------------------------------------------------------------------------------
#Where bindings 
  where bindings are a syntactic construct
    that let you bind to variables at the end of a function
    and the whole function can see them, including all the guards.

#Where binding clause
  #in guards
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body
      where
        name = value
        name = value
  #with pattern matching
    initials :: String -> String -> String
    initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
      where (f:_) = firstname
            (l:_) = lastname
  #in list comprehension
    calcBmis :: (RealFloat a) => [(a, a)] -> [a]
    calcBmis xs = [bmi w h | (w, h) <- xs]
      where bmi weight height = weight / height ^ 2
  #nested
    it's a common idiom to make a function
      and define some helper function in its where clause
      and then to give those functions helper functions as well,
      each with its own where clause.
      
#-------------------------------------------------------------------------------------
#Let binding
  Let bindings let you bind to variables anywhere
    but are very local, so they don't span across guards.
  Let bindings are expressions (like if expression)
    you can cram it almost anywhere

#Let binding clause
      let <bindings> in <expression>
      4 * (let a = 9 in a + 1) + 2  -> 42
      ghci> let zoot x y z = x * y + z
    The names that you define in the let part are accessible to the expression after the in part.
    We omitted the in part of the let binding when we used them in list comprehensions
      because the visibility of the names is already predefined there. 
        But, we could use a let in binding in a predicate and the names defined would only be visible to that predicate. 
    The in part can also be omitted when defining functions and constants directly in GHCi.
      If we do that, then the names will be visible throughout the entire interactive session.
  #to introduce function in a local scope
    [let square x = x * x in (square 5, square 3, square 2)] -> [(25,9,4)]
  #with pattern matching
    cylinder :: (RealFloat a) => a -> a -> a
    cylinder r h =
      let sideArea = 2 * pi * r * h
          topArea = pi * r ^2
      in sideArea + 2 * topArea
  #destructuring tuple with pattern matching
    (let (a,b,c) = (1,2,3) in a+b+c) * 100  ->  600
  #bind to several variables inline
    (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
    ->  (6000000,"Hey there!")
  #in list comprehension
    calcBmis :: (RealFloat a) => [(a, a)] -> [a]
    calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
    
#-------------------------------------------------------------------------------------
#Case expressions
  It's about taking a variable and then executing blocks of code for specific values of that variable
    and then maybe including a catch-all block of code in case the variable has some value for which we didn't set up a case.
  
#Case expressions
  case expression of
    pattern -> result
    pattern -> result
    pattern -> result
    ...
  describeList :: [a] -> String
  describeList xs = "The list is " ++ case xs of [] -> "empty."
                                                 [x] -> "a singleton list."
                                                 xs -> "a longer list."
#using pattern matching
  pattern matching on parameters in function definitions
    is just a syntactic sugar for case expressions.
  Because pattern matching in function definitions is syntactic sugar for case expressions,
    we could have also defined the above function like so:
      describeList :: [a] -> String
      describeList xs = "The list is " ++ what xs
        where what [] = "empty."
              what [x] = "a singleton list."
              what xs = "a longer list."

#-------------------------------------------------------------------------------------
#Recursion 
  a way of defining functions in which the function is applied inside its own definition.
  making a recursive function:
    you define an edge case
    you define a function that does something between some element and the function applied to the rest.
  usually the identity of an operation used in the recursion is the edge case. e.g.
    in recursive sum (with + operator), the identity and edge case is 0 (since n+0=n)
    with list, the identity is usually an empty list []
  see Learn You a Haskell for Great Good! chapter 5
    to see these standard library function is implemented with recursion:
      maximum, replicate, take, reverse, repeat, zip, elem
      
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted
  
#-------------------------------------------------------------------------------------
#Higher order functions
  higher order function is a function that
    take functions as parameters 
    and/or return functions as return values
#Curried functions
  every function in Haskell only takes one parameter
  functions that take more than one parameter is implemented as curried function
  if we call a (multi-parameter) function with too few parameters,
    we get back a partially applied function,
    meaning a function that takes as many parameters as we left out
#Map + Filter = List comprehension
  you can express list comprehension using a combination of map and filter
    this will make the expression more readable and composable (in some cases)
  The filter equivalent of applying several predicates in a list comprehension
    is either filtering something several times or joining the predicates with the logical && function.
#Fold (reduce)
  fold takes a binary function, a starting value (accumulator), and a list to fold up.
  the binary function itself takes two parameters
    which is the accumulator and the first (or last) element (current element)
    and it produces a new accumulator
#Lambdas
    Lambdas are basically anonymous functions that are used because we need some functions only once.
    Normally, we make a lambda with the sole purpose of passing it to a higher-order function.
    \ is used because it kind of looks like the greek letter lambda
    if you don't wrap lambda inside parentheses, the function_body will be from '->' to the end of line
    like normal functions, you can pattern match in lambdas
      the only difference is that you can't define several patterns for one parameter
    People who are not well acquainted with how currying and partial application works
      often use lambdas where they don't need to.
        e.g. using (map (\x -> x + 3)[1,6,3,2]) instead of (map (+3)[1,6,3,2])
      but it's OK to use lambda instead of partial application if it makes your code more readable
      
#Currying infix function
    divideByTen :: (Floating a) => a -> a
    divideByTen = (/10)
    isUpperAlphanum :: Char -> Bool
    isUpperAlphanum = (`elem` ['A'..'Z'])
  Infix functions can also be partially applied by using sections
  To section an infix function,
    simply surround it with parentheses
    and only supply a parameter on one side.
      That creates a function that takes one parameter
      and then applies it to the side that's missing an operand.
  #Exception
    subtractByFour :: (Floating a) => a -> a
    subtractByFour = (subtract 4)
  you can't use (-4) here because (-4) denotes negative integer 4 (and will not return a partially applied function)
  
#Map
    map :: (a -> b) -> [a] -> [b]
    map _ [] = []
    map f (x:xs) = f x : map f xs
  map takes a function and a list, and applies that function to every element in the list, producing a new list.
    map (+3) [1,5,3,1,6]    ->    [4,8,6,4,9]
    map (*) [0..]           ->    [(0*),(1*),(2*),(3*),(4*),(5*)...]
      (map (*) [0..]) !! 100        ->    (100*)
      ((map (*) [0..]) !! 100) 4    ->    400
    map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]     ->    [1,3,6,2,2]
#Filter 
    filter :: (a -> Bool) -> [a] -> [a]
    filter _ [] = []
    filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
  filter takes a predicate and a list, and then returns the list of elements in the list that satisfy the predicate.
  a predicate is a function that tells whether something is true or not (a function that returns a boolean value)
    filter (==3) [1,2,3,4,5]    ->    [3]
    filter even [1..10]         ->    [2,4,6,8,10]
    let notNull x = not (null x) in filter notNull [[1,2,3], [], [3,4,5], [2,2], [], [], []]    ->    [[1,2,3],[3,4,5],[2,2]]
    filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"    ->    "GAYBALLS"
#Fold (reduce)
  foldl (left fold) function folds the list up from the left side
  foldr folds the list up from the right side
    sum :: (Num a) => [a] -> a
    sum xs = foldl (\acc x -> acc + x) 0 xs
#Lambdas
  #basic
    (\parameter1 parameter2 -> function_body)
    (\xs -> length xs > 15)
    (\a b -> a+b) 1 2   ->    3
  #with pattern matching
    map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]