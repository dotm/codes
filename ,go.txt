#File Structure

!main.go
//Run with: go run src/playground/main.go
package main

import (
	"fmt"
	"log"
	"os"
	"time"
)

func main() {
	// this is the main entry point
	// will be run after all init functions are already executed

	// get CLI arguments
	args := os.Args
	programLocation := args[0]
	firstArg := args[1]

	fmt.Println("Hello, " + firstArg + ". You're running: " + programLocation)
}

func init() {
    // init will only run once (when the package is imported by another package for the first time)

	// init is called after all the variable declarations
	// in the package have evaluated their initializers,
	// and those are evaluated only after all
	// the imported packages have been initialized
	fmt.Println("starting program created by", programCreator)

	//used for initializations that cannot be expressed as declarations
	if true { timeNow = time.Now() }

	//used to verify or repair correctness of the program state before real execution begins
	if programCreator == "" {
		log.Fatal("programCreator not set") //verify correctness
	}
	if dbPath == "" {
		dbPath = "~/db" //repair correctness
	}
}

func init() {
	// multiple init functions is allowed
	// order of execution: the init at the top will be run before the init at the bottom
	fmt.Println("ready to run in", dbPath, "at current time", timeNow)
}

const programCreator = "Yoshua"
var dbPath string
var timeNow time.Time

#--------------------------------------------------------------------------------
#Go "comma ok" idiom
    if v, ok := mapConfig["key1"]; ok { fmt.Printf("%s exists", v) }
    func functionName() (value return_type, ok bool){
        ok = false
        if condition_expression {
            value = something
            ok = true
            return
        }
    }

#--------------------------------------------------------------------------------
// single line comment
/* multi line comment */

#--------------------------------------------------------------------------------
#Constant vs. Variable
    constants
        are created at compile time, even when defined as locals in functions
        can only be numbers, characters (runes), strings or booleans
    because of the compile-time restriction,
        the expressions that define constants must be constant expressions (evaluatable by the compiler).
            1<<3 is a constant expression
            math.Sin(4) is not because math.Sin is called at run time
    variable initializer can be a general expression computed at run time

#Variable declaration:
    var variableName = value
    var variableName variable_type
    var variableName variable_type = value
#Short assignment statement for variable
        func main() { k := 3 }
    Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type.

#Constant declaration
    const constantName = value
    const constantName constant_type
    const constantName constant_type = value

#--------------------------------------------------------------------------------
#The blank identifier _
    #in multiple assignment: if _, ok = functionName(); ok {}
    #unused import:
        var _ = package.Function
        var _ package.Type
    #unused variable:
        _ = variableName
    #import for side effect:
        import _ "net/http/pprof"
    #interface check:
        _, ok = variableName.(interfaceName)        // check if variableName conforms to interfaceName
        var _ interfaceName = (*type_name)(nil)     // check if type_name conforms to interfaceName

#Import side effect
    just the import of the package will cause some code (init function) to execute on app start
    putting my system in a state different than it would be without having imported that package

#--------------------------------------------------------------------------------
#Print string
    #basic: fmt.Print("hello world", "!")
    #with new line: fmt.Println("hello world", "!")
    #formatted:
        fmt.Printf("%v %v %v %q", integer_value, float_value, boolean_value, string_value)
        fmt.Printf("the value %v has type %T", value, value)

#Print into io.Writer interface (stream)
    #basic: fmt.Fprint(os.Stdout, "hello world", "!")
    #with new line: fmt.Fprintln(os.Stderr, "hello world", "!")
    #formatted: fmt.Fprintf(CustomStream, "%d", integer_value)

#Output string
    #basic: fmt.Sprint("hello world", "!")
    #with new line: fmt.Sprintln("hello world", "!")
    #formatted: fmt.Sprintf("%d", integer_value)


#Format Specifiers
    numeric formats such as %d do not take flags for signedness or size
        instead, the printing routines use the type of the argument to decide these properties
            var x uint64 = 1<<64 - 1
            fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
            //will print 18446744073709551615 ffffffffffffffff; -1 -1
    the default conversion specifier %v produce exactly what Print and Println would produce
    when printing a struct, the modified format %+v
        annotates the fields of the structure with their names
            fmt.Printf("%v\n", vector)      //will print &{3 -1}
            fmt.Printf("%+v\n", vector)     //will print &{x: 3, y: -1}
    for any value the alternate format %#v
        prints the value in full Go syntax
            fmt.Printf("%#v\n", vector)     //will print &main.Vector{x: 3, y: -1}
    the quoted string format is available through %q
        when applied to a value of type string or []byte
    the %q format also applies to integers and runes,
        producing a single-quoted rune constant.
    the alternate format %#q will use backquotes on type string instead if possible
    the %x works on strings, byte arrays and byte slices as well as on integers,
        generating a long hexadecimal string,
        and with a space in the format (% x) it puts spaces between the bytes.
    prints the type of a value with %T

#Default format for custom type (make custom type printable) using the fmt.Stringer interface
        type Stringer interface { String() string }
        func (t *type_name) String() string {
            return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
        }
    If you need to print values of type type_name as well as pointers to type_name,
        the receiver for String must be of value type;
        the example above used a pointer because that's more efficient and idiomatic for struct types.
    Beware of infinite recursion when defining default format for custom type
        func (m MyString) String() string {
            return fmt.Sprintf("MyString=%s", m)
            // Error: will recur forever (the Sprintf will call this String() method again resulting in infinite recursion)
        }
        func (m MyString) String() string {
            return fmt.Sprintf("MyString=%s", string(m))
            // OK: note the conversion. (the Sprintf here won't call the String() method again)
        }

#--------------------------------------------------------------------------------
#Data types
    #Boolean: bool
        true false
    #Integers:
            int    int8    int16    int32    int64
            uint uint8 uint16 uint32 uint64
            uintptr
            byte        // alias for uint8
            rune        // alias for int32; represents a Unicode code point
        int, uint, and uintptr are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems
    #Float: float32 float64
    #Complex number: complex64 complex128
        Go will default to complex128 for a complex number literal in 64-bit systems
    #Pointer: *value_type
    #string
    #nil
#Zero values
    Variables declared without an explicit initial value are given their zero value:
        Numeric types   : 0
        Boolean type    : false
        String type     : ""
        Pointer         : nil
        Slice           : nil
        Map             : nil
        Channel         : nil
    Struct with omitted fields will have its omitted fields initialized to their respective types' zero values

#Type bending
    Use a type assertion or type switch
        if you have to wrap your concrete type into an interface and want your concrete type back,
    Use a type conversion
        if you need to convert one concrete type to an other
#Type assertions
    provides access to an interface value's underlying concrete value
    can raise runtime error (panic) without the comma ok idiom
        var i interface{} = "Hello"
        s := i.(string)                 //s == "Hello"
        s, ok := i.(string)             //s == "Hello"; ok == true
        f, ok := i.(float64)            //f == 0; ok == false
        f = i.(float64)                 //panic
#Type conversion: concrete_type(valueOfConcreteType)
    var a float64 = 3.8
    var b int = int(a)    //b is 3
#Type switch statement
    var variableName interface{} = functionOfSomeType()
    switch t := variableName.(type) {
        case interfaceName:
            // here t has the type of interfaceName
            fmt.Printf("variableName conforms to interfaceName")
        case bool:
            // here t has the type of bool
            fmt.Printf("boolean %t\n", t)
        case *bool:
            fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
        default:
            // no match; here t has the same type as variableName
            fmt.Printf("unexpected type %T\n", t) // %T prints whatever type t has
    }

#--------------------------------------------------------------------------------
#Data Allocation

#Using new: var variableName *type_name = new(type_name)
    new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T
    it returns a pointer to a newly allocated zero value of type T
    when you define a new data structure, make sure you can use new on it without further initialization
        i.e. it must be ready to use without setting things like this: customDataStructure.property = zero_value
#new and composite literal
    new(structName) is equal to &structName{}

#Using make: var variableName type_name = make(type_name, arguments)
    can only be used to create slices, maps, and channels
    returns an initialized (not zeroed) value of type_name
        we'll get nil value if we use new(T) with slices, maps, and channels
    unlike new(T), make doesn't return a pointer of the type

#--------------------------------------------------------------------------------
#Pointer
        pointer holds the memory address of a value
        Go has no pointer arithmetic
    #declaration: var p *int
    #create pointer: p = &integerVariable
    #dereferencing/indirecting pointer:
        fmt.Println(*p)     // read i through the pointer p
        *p = 21             // set i through the pointer p
    #access struct field through pointer
        (*p).structField
        p.structField       //shorthand

#--------------------------------------------------------------------------------
#Enumerations
        don't use zero values for enum value because it can be mistaken for an uninitialized enum value
    #without custom type
        const (
            Male = 1
            Female = 2
        )
    #with custom type
        const (
            Male    Gender = 1
            Female  Gender = 2
        )

#Using iota enumerator to automate enum value generation
    iota can be part of an expression and the expressions is implicitly repeated
    the first iota value is 0 and hence it can be mistaken for an uninitialized int value
        so we can ignore the first value by assigning to blank identifier
            type ByteSize float64
            const (
                _           = iota
                KB ByteSize = 1 << (10 * iota)
                MB
                GB
                TB
            )
        or assign it as an unknown case
            type ServerStatus int
            const (
                Unknown ServerStatus = iota
                Running
                Stopped
                Resumed
            )
        or just make the first value non-zero
            const (
                Male = iota + 1
                Female
            )
#Producing Alphabets using iota
    const (
        a = string(iota + 'a') // a
        b                      // b
        c                      // c
        d                      // d
        e                      // e
    )

#--------------------------------------------------------------------------------
#Struct: a collection of fields
    #declaration:
        type structName struct {
            fieldName1 field_type
            fieldName2 field_type
            fieldName3 field_type
        }
    #create using composite literal:
        var structVariable = structName{value, value, value}
        var structVariable = structName{fieldName1: value, fieldName2: value}     //partial initialization permitted
        var structVariable = structName{fieldName2: value, fieldName1: value}     //unordered initialization permitted
        var structVariable = structName{}                                         //all struct field set to zero value
    #access field: structVariable.fieldName1

#--------------------------------------------------------------------------------
#Array
        (zero index, homogeneous, fixed-length)
        value type (pass by value)
            assigning one array to another copies all the elements
            passing an array to a function will copy it (and not passing the reference)
        the size of an array is part of its type
            types [10]int and [20]int are distinct
        they are a building block for slices
            array's value property can be useful but also expensive
            if you want efficiency, you can pass a pointer to the array
            but that style isn't idiomatic; use slices instead
        unless the dimensions (length) of an array is fixed, use slices
    #create array with zero values
        var arrayName [length]value_type
        var a [10]int     //initialized to zero values
    #create using composite literal:
        var arrayName [length]value_type = [length] value_type {value, value}
        var arrayName [length]value_type = [length] value_type {index: value, index: value}
        var a [10]int = [10]int{11,22}
        var a [10]int = [10]int{2: 22, 5: 55}
    #access element by index: array[index]
    #change element value at index: array[index] = value

#Slices:
        value type (pass by value)
        a run-time data structure that have 3 fields:
            length: the number of elements the slice currently hold
            capacity: the number of elements in the underlying array, counting from the first element in the slice
            a pointer to its underlying array
        if you assign one slice to another, both will refer to the same array
        a proxy to its underlying array
            changing the elements of a slice
            modifies the corresponding elements of its underlying array
            and other entities can see the change
        a nil slice has a length and capacity of 0 and has no underlying array.
        slices can contain any type, including other slices.
    #create
        #from array:
            var sliceName []value_type = arrayName[upper_index : lower_index]
            var sliceName []value_type = arrayName[1:3]     //will include elements of index 1 and 2 from arrayName
            var sliceName []value_type = arrayName[1:]    //will include elements from index 1 until the last element from arrayName
            var sliceName []value_type = arrayName[:3]    //will include elements of index 0, 1, and 2 from arrayName
            var sliceName []value_type = arrayName[:]     //will include all elements from arrayName
        #slice literal: []bool{true, true, false}
            this creates the array [3]bool{true, true, false}
            then builds a slice that references it
        #using make function to allocate a zeroed array and returns a slice that refers to that array:
            make([]slice_type, length)                //capacity == length
            make([]slice_type, length, capacity)
            b := make([]int, 0, 5)                    // len(b)=0, cap(b)=5
    #reslicing:
        sliceName = sliceName[new_upper_index : new_lower_index]
    #change underlying array:
        sliceName = arrayName[upper_index : lower_index]
    #get slice length: len(sliceName)
    #get slice capacity: cap(sliceName)
    #append value: sliceName = append(sliceName, value, value, ...)

#Two-dimensional slices
    To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices
        type Transform [3][3]float64    // A 3x3 array, really an array of arrays.
        type LinesOfText [][]byte         // A slice of byte slices.
    Because slices are variable-length, it is possible to have each inner slice be a different length.

#--------------------------------------------------------------------------------
#Map: maps keys to values
        pass by reference
        a nil map has no keys, nor can keys be added
        the key can be of any type for which the equality operator is defined:
            integers, floating point, complex numbers, strings,
            interfaces (as long as the dynamic type supports equality),
            pointers, structs, arrays
    #create
        #using make to create empty map:
            mapName := make(map [key_type] value_type)     //e.g. make(map[string]int)
        #using composite literal:
            mapName := map[key_type]value_type {
                keyName: value,
                keyName: value,
            }
    #access element by key: map[keyName]
    #add value to key: map[keyName] = value
    #change value by key: map[keyName] = value
    #delete element by key: delete(map, keyName)
    #check if an element exist at a key:
        elem, isExist := map[keyName]             //if no element found at keyName, isExist will be false and elem will be zero-valued
        _, isExist := map[keyName]

#Set
    A set can be implemented as a map with value type bool
        set := map[string]bool{"uuid": true, "uuid": true}

#--------------------------------------------------------------------------------
Conditional

#If statement
    if condition {
        statements
    } else if condition {
        statements
    } else {
        statements
    }
#If statement with init_statement:
        if init_statement; condition { statements }
        if val, err = functionName(); err == nil { statements }
    variables declared in init_statement are available only inside the if statement
    the else if and else statement can access variables from the if init_statement
        but they can't have an init_statement

#Switch statement
        doesn't fallthrough (break is inserted automatically at the end of each case)
        can use init_statement after the switch keyword (just like if statement)
        can be used without init_statement and expression (used as an if statement)
    switch init_statement; expression {
        case condition:
            statements
        case condition, condition, condition:
            statements
        default:
            statements
    }
#break

#--------------------------------------------------------------------------------
Loop

#For loop
    for i := 0; i < 3; i++ { statements }
    for init_statement; condition_expression; post_statement { statements }
        the init_statement and post_statement is optional:
            for ; condition_expression ; { statements }
            for condition_expression { statements }            //the ; can be omitted if only the condition_expression exist
        variables declared in init_statement are available only inside the loop
#Infinite loop: for { break }     //use break to stop the loop
#While loop: for condition_expression { statements }
#break
#continue

#Label
    label:
    for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
            if j > 3 { break }
            if i > 3 { break label }
            fmt.Println(i, j)
        }
    }

#Iterate over array, string, and slice using range
    for index, value := range sliceName { statements }
    for index := range sliceName { statements }            //capture index only
    for _, value := range sliceName { statements }         //capture value only
    for range sliceName { statements }                     //without capturing index or value

#Iterate over map using range
    for key, value := range mapName { statements }
    for key := range mapName { statements }            //capture index only
    for _, value := range mapName { statements }         //capture value only
    for range mapName { statements }                     //without capturing index or value

#--------------------------------------------------------------------------------
#Function
        first-class object
    #definition
        #basic: func functionName() { function_body }
        #with parameters: func functionName(parameterName parameter_type, parameterName parameter_type) { function_body }
            When consecutive parameters share a type, you can omit the type from all but the last.
                func add(x, y int, z string) { function_body }
        #with return value: func functionName() return_type { return value }
        #with multiple return value: func functionName() (return_type, return_type) { return value, value }
        #with named return value:
                func functionName() (returnName return_type) { return value }
                func split(sum int) (x, y int) {
                    x = sum / 2
                    y = sum - x
                    return            // this will return the latest value of x and y
                }
            the named return values are treated as variables defined at the top of the function
                use them for documentation purposes
        #anonymous function/function literal:
            func (){ function_body }
            func (){ function_body }()    //automatically run the function
            func (parameterName parameter_type, parameterName parameter_type){ function_body }
            func (parameterName parameter_type, parameterName parameter_type){ function_body }(argument, argument)
    #higher-order function:
        func functionName
            (callback func(parameter_type,parameter_type) return_type)    //take a callback function as argument
            func(parameter_type,parameter_type) return_type             //return a function as closure
            { function_body }
    
#Method
        Go doesn't have classes. But, you can define methods on types.
        A method is a function with a special receiver argument
        The receiver argument can be of type parameter_type or a pointer to parameter_type
        All methods on a given type should have either value or pointer receivers, but not both
        The rule about pointers vs. values for receivers is that:
            value methods can be invoked on pointers and values
                if pointer is passed into a method with value receiver, Go will resolve the pointer automatically:
                pointerName.methodName() ---is-resolved-into--> (&pointerName).methodName()
            pointer methods can only be invoked on pointers
                this is because passing value would cause the method
                to receive a copy of the value, so any modifications would be discarded.
                The language therefore disallows this mistake.
    #definition:
        func (receiverArgumentName type) methodName(parameterName parameter_type) return_type { function_body }
        func (v Vertex) Abs() float64 { statements }
    #call: variableName.methodName(argument, argument)
    #add method for types defined in different package (e.g. built-in types):
        type MyInt int                          //use type alias
        func (x MyInt) square() int {           //declare the method on the type alias
            return int(x*x)                     //do type casting to original type if you want to
        }     
        a := MyInt(-2)                          //convert the original type into the type alias
        a.square()                              //use the method (convert it back to the original type if necessary)
#Method with pointer receiver
        type Vertex struct {X, Y float64}
        func (v *Vertex) Scale(f float64) {     //if you don't use the * and declare the receiver as pointer,
            v.X = v.X * f                       //the two lines here won't work
            v.Y = v.Y * f                       //it won't modify the original vertex
        }                                       //hence calling vertex.Scale(2) won't work
    There are two reasons to use a pointer receiver:
        so that the method can modify the value that its receiver points to
        to avoid copying the value on each method call (which can impact efficiency if the value is a large struct)

#Defer statement
        func a() int {
            a := 1
            defer fmt.Println(a)    //call defer right before return if possible
            return a
        }
        func main() {
            defer fmt.Println("world")
            fmt.Println("hello")
        }
        func functionName() {
            file, err := os.Open(filename)
            if err != nil {
                return "", err
            }
            defer file.Close()        // call defer close to the definition of file
        }
    A defer statement defers the execution of a function until the surrounding function returns.
    The deferred call's arguments are evaluated immediately,
        but the function call is not executed until the surrounding function returns.
    Deferred function calls are pushed onto a stack.
        When a function returns, its deferred calls are executed in last-in-first-out order.

#--------------------------------------------------------------------------------
#Interface
    interface type is a set of method signatures
        type interfaceName interface {
            method signature
            method signature
        }
    Interfaces with only one or two methods are common in Go and are usually given a name derived from the method
        type Absolutable interface { Abs() float64 }
        type Writer interface { Write(p []byte) (n int, err error) }   // available in io.Writer
    A type implements an interface simply by implementing its methods (no implements keyword necessary)
    A type can implement multiple interfaces
    It's an idiom in Go to convert the type of an expression to access a different set of methods
        sort.IntSlice(userDefinedSequenceType).Sort()
        fmt.Sprint( []int( userDefinedSequenceType ) )
    Since almost anything can have methods attached
        (except pointer and interface),
        almost anything can satisfy an interface
        including a function type:
            type HandlerFunc func(ResponseWriter, *Request)
            func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) }

#Nil underlying value
    If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.
        var i interfaceName
        var t *type_name
        i = t
        func (t *T) M() { return t == nil }     //this will return true because the underlying value t is nil
    An interface value that holds a nil concrete value is itself non-nil.

#Nil interface
    A nil interface value holds neither value nor concrete type.
        var i interfaceName
        i == nil                //true
    calling a method of a nil interface causes runtime error, unlike calling a method with nil underlying value
        this is because you can handle the nil underlying value inside the function
        e.g. by using a guard like: if t == nil {do something}

#Empty interface: interface {}
    is interface type with zero method signature
    may hold values of any type
    are used by code that handles values of unknown type

#--------------------------------------------------------------------------------
#Embedding
    composition over inheritance
        Go does not provide subclassing,
        but it does have the ability to “borrow” pieces of an implementation
        by embedding types within a struct or interface.

#Embedding interface
    type Reader interface { Read(p []byte) (n int, err error) }
    type Writer interface { Write(p []byte) (n int, err error) }
    type ReadWriter interface {
        Reader
        Writer
    }

#Embedding struct
    type structName struct {
        fieldName field_type
        *anotherStructName
    }
#initialize the struct: structVariable := structName{value, &anotherStructName{}}
#accessing embedded struct: structVariable.anotherStructName

#--------------------------------------------------------------------------------
#Error

#Error interface - go programs express error state with error values
    type error interface {
        Error() string
    }
#Conforming to error interface
    type MyError struct { When time.Time; What string }
    func (e *MyError) Error() string {
        return fmt.Sprintf("at %v, %s", e.When, e.What)
    }
    func run() error {
        return &MyError{time.Now(), "unknown error encountered",}
    }
#Guarding against error
    func main() {
        if err := run(); err != nil { fmt.Println(err) }
        
        i, err := strconv.Atoi("42")
        if err != nil {
            fmt.Printf("couldn't convert number: %v\n", err)
        } else {
            fmt.Println(i)
        }
    }

#Panic and recover
    panic creates a run-time error
        that immediately stops execution of the current function
        and begins unwinding the stack of the goroutine,
        running any deferred functions along the way.
        If that unwinding reaches the top of the goroutine's stack, the program dies.
    However, it is possible to use the built-in function recover
        to regain control of the goroutine and resume normal execution.
    recover must be inside deferred function
#panic
    panic(e interface{})    //takes anything
    panic("usually a string is passed to be printed or logged")
#recover
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
#repanic (recover and panic again)
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
            panic(err)
        }
    }()

#--------------------------------------------------------------------------------
#Exporting
    In Go, a name is exported if it begins with a capital letter.

#Import statement
    import "fmt"
    import "math"
#Factored import statement
    import (
        "fmt"
        "math"
    )
#Import with alias
    import (
        textTemplate "text/template"
        htmlTemplate "html/template"
    )

#--------------------------------------------------------------------------------
#Concurrency
    Do not communicate by sharing memory; instead, share memory by communicating.
        This approach can be taken too far.
        Reference counts may be best done by putting a mutex around an integer variable.
    Although Go's approach to concurrency originates in Hoare's Communicating Sequential Processes (CSP),
        it can also be seen as a type-safe generalization of Unix pipes.

#Goroutine
    go f(x, y, z)
        starts a new goroutine running f
        The evaluation of f, x, y, and z happens in the current goroutine
        the execution of f happens in the new goroutine
    It is
        a function executing concurrently with other goroutines in the same address space
            so access to shared memory must be synchronized
        a lightweight thread managed by the Go runtime
    It is lightweight, costing little more than the allocation of stack space.
        And the stacks start small, so they are cheap,
        and grow by allocating (and freeing) heap storage as required.
    Goroutines are multiplexed onto multiple OS threads
        so if one should block, others continue to run.
        Their design hides many of the complexities of thread creation and management.

#Channel
        a typed conduit through which you can send and receive values with the channel operator <-
        first-in-first-out (queue)
        By default, sends and receives block until the other side is ready.
            This allows goroutines to synchronize without explicit locks or condition variables.
        Only the sender should close a channel, never the receiver.
        Sending on a closed channel will cause a panic.
    #create: channelName := make(chan type_name)
    #send value to channel: channelName <- value
    #receive value from channel: variableName := <- channelName
    #close channel (from sending value): close(channelName)
    #check if channel is closed: variableName, stillOpen := <-ch
        stillOpen will be false if the channel is closed
#Buffered Channel: channel that can be filled by value from the same goroutine
    channelName := make(chan type_name, buffer_length)
    ch := make(chan int, 100)
#Iterate over a channel (until it is closed)
    for value := range channelName { fmt.Println(value) }
#Channel blocking mechanism
    Receivers always block until there is data to receive. 
    If the channel is unbuffered,
        the sender blocks until the receiver has received the value. 
    If the channel has a buffer,
        the sender blocks only until the value has been copied to the buffer; 
        if the buffer is full, this means waiting until some receiver has retrieved a value.

#Example usage of channel and goroutine
    func functionName(ch chan int){ ch <- 1; ch <- 2; close(ch) }
    func main() {
        ch := make(chan int)
        go functionName(ch)
        
        fmt.Println(<-ch)         //print 1
        fmt.Println(<-ch)         //print 2
        fmt.Println(<-ch)         //print 0 since channel is closed; will raise fatal error if channel is not closed
    }
#Example usage of buffered channel
    ch := make(chan int, 2)
    ch <- 1; ch <- 2
    ch <- 3             //overflowing the buffer causes fatal error
    fmt.Println(<-ch)
    fmt.Println(<-ch)
#Using unbuffered channel and goroutine to do something in the background
    c := make(chan int)     // Allocate a channel.
    go func() {             // Start the sort in a goroutine; when it completes, signal on the channel.
        list.Sort()
        c <- 1              // Send a signal; value does not matter.
    }()
    doSomethingForAWhile()
    <-c                     // Wait for sort to finish; discard sent value.
#Using buffered channel and goroutine to implement a semaphore
    var semaphore = make(chan int, MaxResourcesInPool)
    func Serve(queue chan *Request) {
        for req := range queue {
            req := req              // create a new req, shadowing the req from the for loop, this is to avoid reuse behavior of for loop variable
            semaphore <- 1          // increment semaphore
            go func() {
                process(req)        // use the limited resource from the pool
                <-semaphore         // decrement semaphore
            }()
        }
    }
#Managing limited resources without semaphore
    func handle(queue chan *Request) {
        for r := range queue { process(r) }
    }
    func Serve(clientRequests chan *Request, quit chan bool) {
        for i := 0; i < MaxResourcesInPool; i++ {
            go handle(clientRequests)               // Start handlers
        }
        <-quit                                      // Wait to be told to exit
    }

#Select statement
    lets a goroutine wait on multiple communication operations
    select blocks until one of its cases can run, then it executes that case
        It chooses one at random if multiple are ready
    The default case in a select is run if no other case is ready.
        Use a default case to try a send or receive without blocking:
#Example
    func functionName(firstChannel, secondChannel chan int){
        select {
            case variableName := <- firstChannel: fmt.Printf("firstChannel: %v\n", variableName)
            case <- secondChannel:                 fmt.Println("received signal from secondChannel")
        }
    }
    func main(){
        a := make(chan int); b := make(chan int);
        go functionName(a,b)
        a <- 1
    }
#Example with default case
    func main() {
        boom := time.After(3 * time.Second)
        for {
            select {
            case <-boom:
                fmt.Println("BOOM!")
                return
            default:
                fmt.Println("tick")
                time.Sleep(1 * time.Second)
            }
        }
    }

#sync.Mutex
    channels are great for communication among goroutines
    What if we just want to make sure
        only one goroutine can access a variable at a time to avoid conflicts?
        this concept is called mutual exclusion
        the conventional name for the data structure that provides it is mutex
#Example usage
    type SafeCounter struct { // is safe to use concurrently
        v int; mux sync.Mutex;
    }
    func (c *SafeCounter) Increment() {
        fmt.Println("Function called")
        c.mux.Lock();                 fmt.Println("Lock so only one goroutine at a time can access c.v");
        time.Sleep(time.Second);
        c.v++;                        fmt.Printf("Counter changed to %v\n", c.v);
        c.mux.Unlock();             fmt.Println("Release lock");
    }
    func (c *SafeCounter) Value() int {
        c.mux.Lock()
        // Lock so only one goroutine at a time can access the map c.v.
        defer c.mux.Unlock()
        return c.v                    //returns the current value of the counter
    }
    func main() {
        c := SafeCounter{v: 0}
        for i := 0; i < 3; i++ { go c.Increment() }
        time.Sleep(time.Second * 5)
        fmt.Println(c.Value())
    }

#--------------------------------------------------------------------------------
#Generality

If a type exists only to implement an interface
and will never have exported methods beyond that interface,
there is no need to export the type itself.

Exporting just the interface makes it clear
the value has no interesting behavior beyond what is described in the interface.
It also avoids the need to repeat the documentation on every instance of a common method.

In such cases, the constructor should return an interface value rather than the implementing type. 
