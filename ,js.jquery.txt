Core method was defined in the jQuery script
Plugin method was defined by developer to extend or enhance jQuery's core functionality
Utility method is static or shared functions that wrap up oft-used functionality
	utility methods are attached to the $ object so that it won't overwrite other already defined function

If you are using another JavaScript library that uses the $ variable, you can run into conflicts with jQuery
jQuery objects are not 'live'
	A selection only fetches the elements that are on the page at the time the selection is made
	If you update the page, the jQuery object won't be updated automatically; you must reassign the object manually to update it

window.jQuery = window.$ = jQuery = $;
jQuery() = $()
$.fn = $.prototype

#-------------------------------------------------------------------------------------------
#Linking jQuery
	<script type="text/javascript" src="jquery.min.js"></script>	#link to the minified jquery and your jQuery script.js
	<script>														#script is not a void element so that you can attach inline script
		jQuery codes goes here
	</script>
	<script type="text/javascript" src="script.js"></script>		#but it's better to attach script from external file

#Basic jQuery instructions
	find		elements in an HTML document (DOM)
	change		the content of the HTML element
	listen		to what a user does
	animate		content on the page
	talk		over the network to communicate with the server and fetch new content without refreshing the page

#Document Object Model ready
		$(document).ready(function(){ code });
	:=	$(function(){ code });						#shorthand for document ready function
	Code inside $( document ).ready() will only run once the page DOM is ready for JavaScript code to execute.
	Code inside $( window ).load() will run once the entire page (images or iframes), not just the DOM, is ready.

#$() vs $
		$("li").each	vs.		$.each()
	$(): function that convert a selection of DOM and HTML elements to an instance of the jQuery object,
		 and receive and return the selection as 'this'.
	Methods called on jQuery selections are in the $.fn namespace
		$.fn allows you to add or replace a method on the jQuery object
	Methods in the $ namespace are generally utility-type methods, and do not work with selections.
		$.yourFunctionNameHere lets you define a "static" or "shared" utility function.

#-------------------------------------------------------------------------------------------
#Selecting elements
	#using string selectors
		$("h1");		#DON'T FORGET the ""
	  you select an HTML element the same way you select it in CSS selector using the $()
	  every valid CSS selector is a valid jQuery selector
	  jQuery also offers many attribute-based selectors,
		allowing selections based on the content of arbitrary attributes using simplified regex
	#from a DOM element
		$( document.body.children[0] );
	#from a list of DOM elements
		$( [ window, document ] );
	#make a selection in the context of a DOM element
		var firstBodyChild = document.body.children[0];
		$( 'li', firstBodyChild );							#will select the list items of firstBodyChild
	#make a selection within a previous selection
		var $paragraph = $( 'p' );
		$( 'a', $paragraph );								#will select all anchor link inside all paragraph

#Checking if selection contain any elements
	wrong way: if ( $( "div.foo" ) ) { code }			#will return jQuery object (a truthy value)
	right way: if ( $( "div.foo" ).length ) { code }	#will return 0 (a falsy value)

#Assigning selection to a variable
	var $p = $('p');									#you can replace the $p with any legal Javascript variable name
	var $lala = $('.aClass').find('ol').last().prev()

#Refining selections
	$( "div.foo" ).has( "p" );         	#div.foo elements that contain <p> tags
	$( "h1" ).not( ".bar" );          	#h1 elements that don't have a class of bar
	$( "li" ).filter( ".current" );		#list items with class of current
	$( "li" ).first();              	#the first list item
	$( "li" ).eq( 0 );               	#the first list item (zero-index)

#-------------------------------------------------------------------------------------------
#Selecting form elements
jQuery offers several pseudo-selectors that help find elements in forms.		e.g. $( "form :checked" );
	:checked
		targets checked checkboxes, radio buttons, and <select> elements (for <select> elements only, use the :selected selector)
	:disabled
		targets any <input> elements with the disabled attribute
	:enabled
		targets any elements that do not have a disabled attribute
	:input
		selects all <input>, <textarea>, <select>, and <button> elements
	:selected
		targets any selected items in <option> elements:

jQuery provides pseudo selectors to select form-specific elements according to their type:
	:password  :reset  :radio  :text  :submit  :checkbox  :button  :image  :file

#Getting form input value
	<input type='number' class='aClass' value='1'/>
	$('selector').val()			#the selector must refer to (input) e.g. in this case .aClass
	+$('selector').val()		#fetch as number
#Setting form input value
	$('selector').val('new value')

#-------------------------------------------------------------------------------------------
#Getter and Setter
Some jQuery methods can be used to either assign or read some value on a selection.
When the method is called with a value as an argument, it's a setter because it sets (or assigns) that value.
When the method is called with no argument, it gets (or reads) the value of the element.
Setters affect all elements in a selection,
	whereas getters return the requested value only for the first element in the selection,
	with the exception of .text(), which retrieves the values of all the elements.

#Attribute
	the .attr method can act as a setter or getter of HTML elements
	  setter:
		$( "a" ).attr( "href", "allMyHrefsAreTheSameNow.html" );
		$( "a" ).attr({
			title: "all titles are the same too!",
			href: "somethingNew.html"
		});
	  setter with function:
		$( "#myDiv a:first" ).attr( "href", function( index, oldHref ) {
			return "/new/" + oldHref;
		});
		$( "#myDiv a:first" ).attr({
			rel: "nofollow",
			href: function( index, oldHref ) {		#the first argument is zero based index, the second is the old (original) value
				return "/new/" + oldHref;
			}
		});
	  getter:
		$( "a" ).attr( "href" );

#Getter-setter methods
	.html() 	Get or set the HTML contents.
	.text()		Get or set the text contents; HTML will be stripped.
	.attr()		Get or set the value of the provided attribute.
	.width()	Get or set the width in pixels of the first element in the selection as an integer.
	.height()	Get or set the height in pixels of the first element in the selection as an integer.
	.val()		Get or set the value of form elements.
	.position()	Get an object with position information for the first element in the selection, relative to its first positioned ancestor.
					position is a getter only.

#Utility methods
	$.trim(" strings ")				#remove leading and trailing whitespace
	$.each()						#see iterating over objects for details
	$.inArray("value", arrayName)	#return a value's index in an array, or -1 if the value is not in the array
	$.extend(object, object)		#changes the properties of the first object using the properties of subsequent objects
	$.proxy()						????????
  #Testing Type
	$.isArray()
	$.isFunction()
	$.isNumeric()
	$.type()

#Method chaining
	$( "#content" ).find( "h3" ).eq( 2 ).html( "new text for the third h3!" );
	$( "#content" )
		.find( "h3" )
		.eq( 2 )
		.html( "new text for the third h3!" );
  jQuery also provides the .end() method to get back to the original selection should you change the selection in the middle of a chain:
	$( "#content" )
		.find( "h3" )
		.eq( 2 )
			.html( "new text for the third h3!" )
			.end() // Restores the selection to all h3s in #content
		.eq( 0 )
			.html( "new text for the first h3!" );
  Extensive chaining can make code extremely difficult to read, modify, and debug.

#-------------------------------------------------------------------------------------------
#Moving elements
	Place the selected element(s) relative to another element.
			$( "#myList li:first" ).appendTo( "#myList" );		#Make the first list item the last list item
		.appendTo()
		.prependTo()
		.insertBefore()
		.insertAfter()
	Place an element relative to the selected element(s).
			$( "#myList" ).append( $( "#myList li:first" ) );	#Make the first list item the last list item:
		.append()
		.prepend()
		.before()
		.after()

#Cloning elements
	$( "#myList li:first" ).clone().appendTo( "#myList" );
  If you need to copy related data and events, be sure to pass true as an argument to .clone().

#Removing elements
	Use .remove() to permanently remove the selection from the page
		While .remove() does return the removed element(s),
		associated data and events attached will be deleted permanently
	Use .detach() if you need the data and events to persist
	Use .empty() to dispose of the element's inner HTML.
		this is for when you want to leave the element on the page but remove its contents.

#Creating New Elements
  The element created is stored in the memory. If you want to make it appear in the web page, use methods to move element.
	$( "<li class=\"new\">new list item</li>" );
	$( "<a/>", {
		html: "This is a <strong>new</strong> link",
		"class": "new",									#quoted because class is a reserved word
		href: "foo.html"
	});
  If you're adding many elements to the same container, concatenate all the HTML into a single string,
  and then append that string to the container instead of appending the elements one at a time.
	var myItems = [];	var $myList = $( "#myList" );
	for ( var i = 0; i < 100; i++ ) {
		myItems.push( "<li>item " + i + "</li>" );	}
	$myList.append( myItems.join( "" ) );

#Manipulating elements
  see #Attribute

#-------------------------------------------------------------------------------------------
#Native DOM Elements vs jQuery Objects
	Document Object Model (DOM for short) is a representation of an HTML document.
		It may contain any number of DOM elements.
		Elements have properties like any JS object (attributes and methods).
		These properties are the only way to interact with the web page.
	The jQuery object wraps DOM elements to make them easy to work with.
		When creating or selecting elements with jQuery, the result will be wrapped in a new jQuery object.

	Many developers prefix a $ to the name of variables that contain jQuery objects to differentiate it from DOM element.
		This distinction is important because Native DOM methods and properties are not present on the jQuery object, vice versa.
	If the situation calls for the native DOM elements (e.g. checking equality through ===), they may be accessed through:
		the .get() method
			var firstHeading = $( "h1" ).get( 0 );
		array-style subscripting
			var firstHeading = $( "h1" )[ 0 ];

#-------------------------------------------------------------------------------------------
#Traversal
Traversing can be broken into 3 basic parts: parents(up), children(down), and siblings(sideways)
Each of these methods can optionally be passed string selectors to filter selection
Some can also take another jQuery object to filter your selection
	#Parents
	  .parent();			 			  #select direct parent
		.parents();						  #select all ancestor of an element
		.parentsUntil( "div" );	#select all parents of an element up to, but not including the selector
	  #Closest parent
		Select the closest parent; only one parent will be selected and the initial element itself is included in the search
	 	$( "li.child" ).closest( "ul" ); 	#returns [ ul.parent ]
	 	$( "ul.parent" ).closest( "ul" );	#returns [ ul.parent ] as the selector is also included in the search
	#Children
		.children();					#select an element's direct children
		.find();						#select all descendant of an element
	#Siblings
		.next();						#select next sibling
		.prev();						#select previous sibling
		.siblings						#select all siblings
		.nextAll();						#select all the next siblings
		.prevAll();						#select all the previous siblings
	  nextAll and prevAll methods will put the siblings in an array ordered from closest to farthest of the selector
	  siblings method will put the siblings in an array ordered from first to last element
	#Walking the DOM with method chaining
		.nextAll().first();				#:= .next()
		.prevAll().first();				#:= .prev()
		.prevAll().last();				#:= .first
		.nextAll().last();				#:= .last()
		.first().next()					#second element
		.last().prev()					#penultimate element
avoid traversals that go from one container to another
too much traversals will be likely to break if the HTML is changed

#-------------------------------------------------------------------------------------------
#Getting CSS value
	.css('attribute')
		.css("font-size") := .css("fontSize")
#Setting CSS from jQuery
	.css('attribute','value')
		$('selector').css(fontSize,'14px');
	.css({Javascript object})							#set more than one attribute
		$('selector').css({ 'display':'block',			#notice the use placement of : and ,
							color	 :'red'
							fontSize :'14px'});
#Setting CSS using class and CSS
	.addClass('className')		#DO NOT use the dot (.className)
	.removeClass('className')
	.hasClass('className')		#check whether className exists in the element
	.toggleClass('className')	#hasClass ? removeClass : addClass
  Whenever possible try to use class instead of modifying CSS directly in jQuery
	<div class='aClass'></div>								#in HTML
	.highlight {background-color:yellow}					#in CSS
	$('div').find('.aClass').addClass('highlight')

#Basic dimensions methods (getter-setter)
	.width();
	.height();
	.position();

#Assigning jQuery function
		function sayHello( event ) { alert( "Hello." ); }
		$( "#button" ).on( "click", sayHello );
	Don't put () at the end of sayHello if you want the function to execute after the event is triggered (not immediately)

#-------------------------------------------------------------------------------------------
#Getting HTML data
	<selector data-name='value'></selector>
	.data('name')	->	'value'
	.data()										#return all key-value pair stored
#Setting HTML data
	.data('name','value')						#the value can also be a JS, jQuery, or DOM object
#Converting strings to number
	var amount = +$(this).data('price');		#notice the +

#-------------------------------------------------------------------------------------------
#Iterating over objects
	$.each()
		a generic iterator function for looping over object, arrays, and array-like objects that are not jQuery collections.
		.each(), not $.each(), should be used for iterating over elements in a jQuery selection
			$.each(array, function( index, value ) { codes });
			$.each(object, function( key, value ) { codes });
	.each()
		is used directly on a jQuery collection.
		iterates over each matched element in the collection and performs a callback on that object.
		the second argument points to 'this' object
			$( "li" ).each( function( index, element ){ codes; });
#Mapping objects
	use cases:
		translates a set of elements in the jQuery object into another set of values
		create an array or concatenated string based on all matched elements in our jQuery selector
	.map()
		works on jQuery element collections
		the index argument comes before element
			$( "li" ).map( function(index, element) {
				return this.id;
			}).get();
		.map() always returns a jQuery-wrapped collection
		use .get() to return a basic JavaScript array we can work with
		to concatenate into a string, chain the plain JS .join() array method after .get()
	$.map()
		works on plain JavaScript arrays, so .get() isn't necessary
		the value argument comes before index
			$.map( arr, function( value, index ) {
				return value.id;
			});

#Implicit iteration
	$( "li" ).addClass( "newClass" );			#every list item will be iterated and added the newClass
  .each() is required when we need to get information from the element before setting a new value.
	$( "input" ).val( $( this ).val() + "%" );	#this will NOT work because .val() does not change the execution context, so this === window
	$( "input" ).each( function( i, el ) {		#this will work
		var $elem = $( el );
		$elem.val( $elem.val() + "%" );
	});
  this work because setter methods applied to each element in the matching set
  the arguments passed to the callback are the index of element within the set and the result of the getter signature of the method.
	$( "input" ).val(function( index, value ) {
		return value + "%";
	});
  in implicit iteration, traversal methods such as .children() or .parent()
	will act on each matched element in a collection,
	returning a combined collection of all children or parent nodes.
#Other methods that require .each():
	.attr() 		#getter only
	.css() 			#getter only
	.data() 		#getter only
	.height() 		#getter only
	.html() 		#getter only
	.innerHeight()
	.innerWidth()
	.offset() 		#getter only
	.outerHeight()
	.outerWidth()
	.position()
	.prop() 		#getter only
	.scrollLeft() 	#getter only
	.scrollTop() 	#getter only
	.val() 			#getter only
	.width()		#getter only
  why .each() is required:
	in most cases, the "getter" signature returns the result from the first element in a jQuery collection
	while the setter acts over the entire collection of matched elements
		the exception is .text() where the getter will return a concatenated string of text from all matched elements

#-------------------------------------------------------------------------------------------
#Get index of a value using .index() function
	  will implicitly call .first() on the original jQuery object before index if .first() is not specified explicitly
	  the index has zero-index base
	  if the element is not found, .index() will return -1
	#with no argument
		$( "li" ).index()	->		$( "li" ).first().index()		#first is implicit
	  search the first original object and return its index in relation to its siblings
	#with string argument
		$( "li.secondItem" ).index( "li" )		->		1
	  create an array of jQuery object from the DOM using the argument selector
	  search the first original object and return its index in relation to the array created
	#with a jQuery Object Argument
		$( "li" ).index( $( ".secondItem" ) )	->		$( "li" ).first().index( $( ".secondItem".first() ) )
	  the first element of the jQuery object that passed into .index()
	   is being checked against all of the elements in the original jQuery object.
	#with a DOM Element Argument
	  the DOM element that's passed into .index()
	   is being checked against all of the elements in the original jQuery object.

#-------------------------------------------------------------------------------------------
Listening for event:
	wait for the browser to tell you that a specific event has occurred
	 and then specify how the page should react
Event listener:
	methods attached to the DOM or jQuery object prototype
	used to tell when a specific event has occurred
Event handler:
	is executed whenever the event occurs or until the event is unbound.
	is used to specify to the browser what to do when an event occurs
Event delegation: a process by which an element higher in the DOM tree listens for events occurring on its children.
	Event delegation allows us to attach a single event listener, to a parent element,
	 that will fire for all descendants matching a selector,
	 whether those descendants exist now or are added in the future.
Event bubbling (propagation):
	for most events, whenever an event occurs on a page,
	 the event travels from the element it occurred on, up to its ancestors
	 until it reaches the root element (window)

#Event binding
	event listeners acts on elements that exist at the time you set up the listeners
	elements created after the listeners are established won't pick up event behaviors you've set up previously
	use event delegation to make event behaviors extended to new elements without having to rebind them
  #using convenience methods
		$( "#button" ).click(function( event ) { codes; });
	convenience methods: syntactic sugar (shorthand) for the .on() method
		.click(), .focus(), .blur(), .change(), etc
  #using .bind()
	the syntax is the same as .on() method; bind is just an alias
  #using .on() method
		$( "#button" ).on( "click", function( event ) { codes; });
	use on method to:
	  bind the same handler function to multiple events
	  provide data to the event handler
	  work with custom events
	  pass an object of multiple events and handlers.
  #attach event handler to 'body' to listen and respond whenever *any* button is clicked on the page.
		$( "body" ).on({
			click: function( event ) { codes; }
			}, "button" );
	alternative syntax:
		$( "body" ).on( "click", "button", function( event ) { codes; });

#Handling event
  #Connecting events
	#Simple event binding
		$( "p" ).on( "click", function() { codes; });
	#Many events, one handler
		$( "div" ).on( "mouseenter mouseleave", function() { codes ;});
	#Many events and handlers
		$( "div" ).on({
			mouseenter: function() { codes; },
			mouseleave: function() { codes; },
			click: function() { codes; }		});
	#Binding events to elements that don't exist yet
		see Event delegation
  #Connecting events to run only once
	.one() accepts the same arguments as .on()
	$( "p" ).one( "click", function() {
		alert( "You just clicked this for the first time!" );
		$( this ).click(function() {
			alert( "You have clicked this before!" );
		});
	});
  #Disconnecting events
	unbinding all click handlers on a selection:
		$( "p" ).off( "click" );
	unbinding a particular click handler, using a reference to the function
		var foo = function() { alert( "foo" ); };
		var bar = function() { alert( "bar" ); };
		$( "p" ).on( "click", foo ).on( "click", bar );
		$( "p" ).off( "click", bar );						#foo will stay bound to the click event
  #Namespacing events
		$( "p" ).on( "click.myNamespace", function() { codes; } );
		$( "p" ).off( "click.myNamespace" );	#unbind only the click event handler
		$( "p" ).off( ".myNamespace" ); 		#unbind all events in the namespace

#Event object
		$( "#button" ).click(function( event ) { codes; });
	event object is optional, is passed to the callback function, and is conventionnaly called as event
	the event object contains a number of other useful properties and methods, including:
		pageX, pageY		#mouse position at the time the event occurred, relative to the top left of the page.
		type				#type of the event (e.g. "click")
		which				#the button or key that was pressed
		data				#any data that was passed in when the event was bound
		target				#the DOM element that initiated the event
		preventDefault()	#prevent the default action of the event
		stopPropagation()	#stop the event from bubbling up to other elements.
			to utilize both .preventDefault() and .stopPropagation(), you can instead just 'return false'
		originalEvent		#the event object that the browser itself created
  #Inspect event object
	$( "form" ).on( "submit", function( event ) {
		event.preventDefault();
		console.log( event );		});
  #Passing data to the event handler
	$( "p" ).on( "click", {
		foo: "bar"
	}, function( event ) {
		console.log( event.data.foo );	-> "bar"
	});
#Accessing DOM element
	In addition to the event object, event handling function also has access to the DOM element
		that the handler was bound to via the keyword 'this'.
	To turn the DOM element into a jQuery object that we can use jQuery methods on,
		simply do $( this )
		the DOM element turned to jQuery object can also stored in a variable
			var $element = $( this )

#Event delegation
	$( "ul" ).on( "click", "li", function() {
		// If the triggering element of the event (click) matches the second parameter (li),
		// the function codes will run
	});
  #Open link in new tab using event delegation
	$( "#list" ).on( "click", "a", function( event ) {
		var $elem = $( this );
		if ( $elem.is( "[href^='http']" ) ) {
			$elem.attr( "target", "_blank" );
		}
	});
   with more refined selector:
	$( "#list" ).on( "click", "a[href^='http']", function( event ) {
		$( this ).attr( "target", "_blank" );
	});

#Triggering event handler
  #.trigger() method
		$( "a" ).trigger( "click" );		#This will not change the current page
	a way to trigger the event handlers bound to an element without any user interaction
	.trigger() function cannot be used to mimic native browser events
	if you just want to execute specific function, don't use the trigger method
	 instead, store the function in a variable and call it from that variable
  #.triggerHandler()
	There are four differences between .trigger() and .triggerHandler()
		.triggerHandler() only triggers the event on the first element of a jQuery object.
		.triggerHandler() cannot be chained. It returns the value that is returned by the last handler, not a jQuery object.
		.triggerHandler() will not cause the default behavior of the event (such as a form submission).
		events triggered by .triggerHandler(), won't bubble up the DOM hierarchy. Only the handlers on the single element will fire.
#Trigger a native browser event
	use document.createEventObject for < IE9
	document.createEvent for all other browsers
	use the simulate jQuery plugin
		$( "a" ).simulate( "click" );

#Custom events
  Defining custom event
	$( ".room .lightbulb" ).on( "light:toggle", function( event ) {
		var $light = $( this );
		if ( $light.is( ".on" ) ) {
			$light.removeClass( "on" ).addClass( "off" );
		} else {
			$light.removeClass( "off" ).addClass( "on" );
		}
	});
  Calling custom event
	$( ".switch, .clapper" ).click(function() {
		var $room = $( this ).closest( ".room" );
		$room.find( ".lightbulb" ).trigger( "light:toggle" );
	});
#Custom data of .on() and .trigger()
	$( document ).on( "myCustomEvent", {
		foo: "bar"
	}, function( event, arg1, arg2 ) {
		console.log( event.data.foo ); // "bar"
		console.log( arg1 );           // "bim"
		console.log( arg2 );           // "baz"
	});

	$( document ).trigger( "myCustomEvent", [ "bim", "baz" ] );

#Event Helpers

#.hover()
	$( "#menu li" ).hover(function() { codes; });
pass one or two functions to be run when mouseenter and mouseleave events occur on an element
	if you pass one function, it will be run for both events
	if you pass two functions, the first will run for mouseenter, and the second will run for mouseleave

#--------------------------------------------------------------------------------
#Effects
  you can animate effects by inserting 'slow', 'normal', or 'fast' as argument: .show("fast")
   or by inserting the amount of miliseconds as integer: .show( 1000 )	-> 1 second
  normal speed is 400 (miliseconds), fast is 200, slow 600
	.show()		.hide()			.toggle()
	.slideUp()	.slideDown()	.slideToggle()
	.fadeIn()	.fadeOut()		.fadeToggle()

#Animation callback function
  effect functions will start the effect and immediately return the jQuery object passed into it
   and the next method (if any was chained) will run immediately while the effect is still running
  in this code, the class will be added while the fadeIn effect is still running:
	$( "p.hidden" ).fadeIn( 750 ).addClass( "lookAtMe" );
  to defer an action until after an animation has run to completion:
	$( "p.hidden" ).fadeIn( 750, function() {
		$( this ).addClass( "lookAtMe" );		#this function will run after fadeIn effect is complete
	});
  if your selector returns no elements, your animation callback will never run
  if you want to run the callback whether or not any element exists:
	var $someElement = $( "#nonexistent" );
	var callback = function() {	codes; };
	if ( someElement.length ) {
		someElement.fadeIn( 300, callback );
	} else {
		callback();								#the () will run the function
	}

#Managing Animation Effects
	.delay()	#insert argument in miliseconds
	.stop()
  #jQuery.fx
	#jQuery.fx.speeds
		{slow: 600, fast: 200, _default: 400} #Default speed is used for "normal"
	  You can modify any of these settings and even introduce some of your own:
		jQuery.fx.speeds.fast = 300;
		jQuery.fx.speeds.blazing = 100;
	#jQuery.fx.interval
	  controls the number of fps displayed in an animation
	#jQuery.fx.off
	  can be set to true to disable all animations
  #Adding a stop all animation button
	$( "<button type='button'></button>" )
		.text( "Stop All Animations" )
		.on( "click", function() {
			$( "body *" ).filter( ":animated" ).stop();
		})
		.appendTo( document.body );
  #Adding a disable animation button
	$( "<button type='button'></button>" )
		.text( "Disable Animations" )
		.on( "click", function() {
			jQuery.fx.off = true;
		})
		.appendTo( document.body );

#Custom Effects
  to animate arbitrary CSS properties use .animate()
  color-related properties can only be animated with color plugin.
	.animate({Javascript object}, speed, callback);
	$( "div.funtimes" ).animate(
		{
			left: "+=50",
			opacity: 0.25
		},
		300,
		function() {
			console.log( "done!" );
		}
	);
Easing: the manner in which an effect occurs whether the rate of change is steady, or varies over the duration of the animation.
  jQuery includes only two methods of easing: swing and linear.
  more are available using plugin
#Per-property easing using the .animate() method
		$( "div.funtimes" ).animate({
			left: [ "+=50", "swing" ],
			opacity: [ 0.25, "linear" ]
		}, 300 );

#Animating element
  .animate({Javascript object},speed)
	#Using if else to toggle animation
		$('selector').on('click',function(){
			$(this).toggleClass('move-up');
			if($(this).hasClass('move-up')){
				$(this).animate({'top':'-10px'},fast);
			}else{
				$(this).animate({'top':'0px'},fast);
			}
		});
	#Using CSS transition attribute
		$('selector').on('click',function(){
			$(this).toggleClass('move-up');});
		selector {transition: top 0.2s;}			#in CSS; you might have to use browser attribute e.g. -moz-transition
		.move-up {top: -10px;}

#--------------------------------------------------------------------------------
#Queue
  as callbacks
	$( ".box" )
		.animate( { height: 20 }, "slow")
		.queue( function() {
			$( "#title" ).html( "executing callback function" );
			$( this ).dequeue();
		} );
  calling .queue() without passing it functions will return the queue of that element as an array
	$( ".box" ).queue( "steps", function( next ) {
		console.log( "I fired!" );
		next();
	} );
	console.log( $( ".box" ).queue( "steps" ) );
	$( ".box" ).dequeue( "steps" );


#Dequeue
  .dequeue() tells jQuery to continue to the next item in the queue
  another way of dequeuing is by calling the function that is passed to your callback
   that function will automatically call .dequeue() for you.
	.queue( function( next ) {
		console.log( "I fired!" );
		next();
	} );

#Custom Queues
  the default queue name is fx
  elements can have multiple queues attached,
   and each of these queues can have different names
  specify a custom queue name as the first argument to the .queue() method
	$( ".box" )
		.queue( "steps", function( next ) {
			console.log( "Step 1" );
			next();
		} )
		.queue( "steps", function( next ) {
			console.log( "Step 2" );
			next();
		} )
		.dequeue( "steps" );
  every queue except for the default 'fx' has to be manually kicked off by calling .dequeue() and passing it the name of the queue

#Clearing The Queue
  .clearQueue() method will remove all functions on the queue that have not been yet executed
	$( ".box" )
		.queue( "steps", function( next ) {
			console.log( "Will never log because we clear the queue" );
			next();
		} )
		.clearQueue( "steps" )
		.dequeue( "steps" );
#Replacing The Queue
  When you pass an array of functions as the second argument to .queue(), that array will replace the queue.
	$( ".box" )
		.queue( "steps", function( next ) {
			console.log( "I will never fire as we totally replace the queue" );
			next();
		} )
		.queue( "steps", [
			function( next ) {
				console.log( "I fired!" );
				next();
			}
		] )
		.dequeue( "steps" );

#--------------------------------------------------------------------------------
#Asynchronous JavaScript and XML
AJAX requests run asynchronously.
  the $.ajax method returns before the request is finished (before the success callback runs)
  if the ajax method contain a return statement,
  it will run before the request is finished and return data before it is defined, causing an error.
JSON cannot represent function or date objects.
$.ajax() and ajax convenience methods returns a jqXHR object (jQuery XML HTTP Request) which has a host of powerful methods.

#$.ajax()
  takes a configuration object that contains all instructions jQuery requires to complete the request
  url can also be passed as the first argument to $.ajax(), and the options object as the second argument
    $.ajax( "post.php", {
        // url: "post.php",
        data: { id: 123 },
        type: "GET",
        dataType : "json",
        success: function( json ) {
            $( "<h1>" ).text( json.title ).appendTo( "body" );
            $( "<div class=\"content\">").html( json.html ).appendTo( "body" );
        },
        error: function( xhr, status, errorThrown ) {
            alert( "Sorry, there was a problem!" );
            console.log( "Error: " + errorThrown );
            console.log( "Status: " + status );
            console.dir( xhr );
        },
        complete: function( xhr, status ) {
            alert( "The request is complete!" );
        }
    });
  configuration object options:
    async       #whether the request should be sent synchronously. Defaults to true.
    cache       #whether to use a cached response if available. Defaults to true for all dataTypes except "script" and "jsonp".
    complete    #callback function to run when the request is complete, regardless of success or failure.
    context     #the scope in which the callback function(s) should run
    data        #the data to be sent to the server. can be an object or a query string
    dataType    #type of data you expect back from the server.
    error       #callback function to run if the request results in an error
    jsonp       #the callback name to send in a query string when making a JSONP request. Defaults to "callback".
    success     #callback function to run if the request succeeds.
    timeout     #time in milliseconds to wait before considering the request a failure.
    traditional #Set to true to use the param serialization style in use prior to jQuery 1.4
    type        #type of the request, "POST" or "GET". Defaults to "GET".
    url         #URL for the request.
  the url option is the only required property of the $.ajax() configuration object; all other properties are optional.

#AJAX Convenience Methods
    $.get       #Perform a GET request to the provided URL.
    $.post      #Perform a POST request to the provided URL.
    $.getScript #Add a script to the page.
    $.getJSON   #Perform a GET request, and expect JSON to be returned.
In each case, the methods take the following arguments, in order:
    url                 #The URL for the request. Required.
    data                #The data to be sent to the server. can be an object or a query string
      Note: This option is not valid for $.getScript.
    success callback    #A callback function to run if the request succeeds.
    data type           #type of data you expect back from the server.
      Note: This option is only applicable for methods that don't already specify the data type in their name.

#Using the jqXHR object with convenience method
  capture the returned jqXHR object in a variable
  we can use the object to attach callbacks to the request, even after the request has completed
    .then() method takes at most 2 functions as arguments
      the first is success callback; the second is error callback
      we can call .then() on a request as many times as we'd like; it's a first-in, first-out queue.
    use .done() and .fail() methods of the request object to attach success and error callback separately
    use .always() method of the request object to attach a callback that runs on success or failure
  e.g.
    var req = $.ajax({ url: '/data/people.json', dataType: 'json' });
    req.then( function( resp ){ codes; }; , function( req, status, err ) { codes; }; );

#$.fn.load
  .load() is called on a selection
  it fetches HTML from a URL, and uses the returned HTML to populate the selected element(s).
  In addition to providing a URL to the method, you can optionally provide a selector;
    jQuery will fetch only the matching content from the returned HTML.
  Using .load() to populate an element
    $( "#newContent" ).load( "/foo.html" );
  Using .load() to populate an element based on a selector
    $( "#newContent" ).load( "/foo.html #myDiv h1:first", function( html ) {
        alert( "Content updated!" );
    });

#Ajax Events
  to perform an operation whenever an Ajax request starts or stops, e.g. show or hide a loading indicator
    rather than defining this behavior inside every Ajax request
    bind Ajax events to elements just like you'd bind other events
  setting up a loading indicator using Ajax Events
    $( "#loading_indicator" )
        .ajaxStart(function() { $( this ).show(); })
        .ajaxStop( function() { $( this ).hide(); });

#AJAX and Forms
  #Serializing form inputs in jQuery
    use .serialize() or .serializeArray()
    taking form input and converting it to a query string format
    the .serialize() method serializes a form's data into a query string
    for the element's value to be serialized, it MUST have a name attribute
    values from inputs with a type of checkbox or radio are included only if they are checked
      $( "#myForm" ).serialize();          // Turning form data into a query string
        // Creates a query string like this: field_1=something&field2=somethingElse
    sometimes your application would work better if you sent over an array of objects, instead of just the query string
      $( "#myForm" ).serializeArray();     // Creating an array of objects containing form data
        // Creates a structure like this:
        [ {name : "field_1", value : "something" },
          {name : "field_2", value : "somethingElse"}   ]
  #Client-side validation
    Using validation to check for the presence of an input:
    $( "#form" ).submit(function( event ) {
        if ( $( ".required" ).val().length === 0 ) {
            // show error message here
            event.preventDefault();            // Prevent the form from submitting
        } else {
            // Run $.ajax() here
        }
    });
    check for invalid characters in a phone number:
    // Validate a phone number field
    $( "#form" ).submit(function( event ) {
        var inputtedPhoneNumber = $( "#phone" ).val();
        var phoneNumberRegex = /^\d*$/;                 // Match only numbers

        // If the phone number doesn't match the regex
        if ( !phoneNumberRegex.test( inputtedPhoneNumber ) ) {
            // show error message here
            // Prevent the form from submitting
            event.preventDefault();
        } else {
            // Run $.ajax() here
        }
    });
  #Prefiltering
    prefilter: a way to modify the ajax options before each request is sent
    modify all cross-domain requests through a proxy (using a proxy with a prefilter):
        $.ajaxPrefilter(function( options, originalOptions, jqXHR ) {
            if ( options.crossDomain ) {
                options.url = "http://mydomain.net/proxy/" + encodeURIComponent( options.url );
                options.crossDomain = false;
            }
        });
    you can pass in an optional argument before the callback function that specifies
      which dataTypes you'd like the prefilter to be applied to.
    prefilter to only apply to JSON and script requests, we'd do:
        $.ajaxPrefilter( "json script", function( options, originalOptions, jqXHR ) {
            // Do all of the prefiltering here, but only for
            // requests that indicate a dataType of "JSON" or "script"
        });

#JSONP
JSONP isn't exactly AJAX
  rather than using the browser's XHR functionality,
  it works by inserting a script tag into the page that contains the requested data,
  "padded" with a function wrapper.
jQuery lets you make a JSONP request with $.ajax()
  by specifying 'jsonp' as the dataType in the configuration object.
An API that offers JSONP will specify the name of the callback parameter to use in the query string;
  generally, this name is callback, and so jQuery uses that as its default
  however, you can override this callback name by specifying the jsonp property in the configuration object
CORS (cross-origin resource sharing) is another option for enabling cross-origin requests.
  However, it is not supported on older browsers,
  and it requires server-side configuration and manipulation of the XHR headers in order to work.
#Using YQL and JSONP
    $.ajax( "http://query.yahooapis.com/v1/public/yql", {
        // The name of the callback parameter, as specified by the YQL service
        jsonp: "callback",

        dataType: "jsonp",

        // Tell YQL what we want and that we want JSON
        data: {
            q: "select title,abstract,url from search.news where query=\"cat\"",
            format: "json"
        },

        success: function( response ) {
            console.log( response ); // server response
        }
    });
  jQuery handles all the complex aspects of JSONP behind-the-scenes
  all we have to do is tell jQuery the name of the JSONP callback parameter specified by YQL ("callback" in this case)
    otherwise the whole process looks and feels like a normal Ajax request
#$.getJSON()
    you can use the $.getJSON() convenience method to make a JSONP request
    if the URL includes callback=? or similar, then jQuery will treat it as a JSONP request.
    $.getJSON( '/data/search.jsonp?q=a&callback=?',
      function( resp ) { $( '#target' ).html( 'Results: ' + resp.results.length ); }
    );
#JSON methods
  JSON.stringify()
  JSON.parse()
  jQuery.parseJSON()

#--------------------------------------------------------------------------------
#Method list
.text()							#fetching an element text
	.text("some strings")		#replace an element text with another text (can be strings or number)
.filter('selector')
	$('#anID').filter(".aClass")			#select only and all the element with .aClass inside #anID
.length								#display number of nodes
	alert($('selector').length)
.size ??????????????????????

#--------------------------------------------------------------------------------
JQFundamental

Deferreds
The jqXHR object is a special flavor of a deferred
Deferreds is a powerful way for managing asynchronous code:
  it provide a means to react to the eventual success or failure of an asynchronous operation
  it reduce the need for deeply nested callbacks
Just like with a jqXHR, we can attach success and error handlers to a promise
  using .then(), .done(), .fail(), .always()

$.Deferred
jQuery lets you create your own deferreds using $.Deferred()

Here, we run a function in a setTimeout,
  and "resolve" our deferred with the return value of that function.
  We return the deferred's "promise"
  promise: an object to which we can attach callbacks, but which doesn't have the ability to modify the outcome of deferred itself.
  We "reject" the deferred if anything goes wrong with running the provided function.

function doSomethingLater( fn, time ) {
  var dfd = $.Deferred();

  setTimeout(function() {
    dfd.resolve( fn() );
  }, time || 0);

  return dfd.promise();
}
var promise = doSomethingLater(function() { console.log( 'This function will be called in 100ms' ); }, 100);

#pipe()
We can use the .pipe() method of a promise to react to the resolution of an asynchronous operation
  by manipulating the value it returns and creating a new deferred.
As of jQuery 1.8, the .then() method of a promise behaves like .pipe().

function doSomethingLater( fn, time ) {
  var dfd = $.Deferred();

  setTimeout(function() {
    dfd.resolve( fn() );
  }, time || 0);

  return dfd.promise();
}

var dfd = doSomethingLater(function() { return 1; }, 100);

dfd
  .pipe(function(resp) { return resp + ' ' + resp; })
  .done(function(upperCaseResp) {
    $( '#target' ).html( upperCaseResp );
  });

#Reacting to maybe-asynchronous operations
Sometimes we have an operation that might return immediately, or might be asynchronous
  e.g. a function does something async the first time it runs, and then caches the value for future use.
  In this case, we can use $.when() to react to either case.

function maybeAsync( num ) {
  var dfd = $.Deferred();
  // return a deferred when num === 1
  if ( num === 1 ) {
    setTimeout(function() { dfd.resolve( num ); }, 100);
    return dfd.promise();
  }
  // return immediately otherwise
  return num;
}

// this will resolve async
$.when( maybeAsync( 1 ) ).then(function( resp ) {
  $( '#target' ).append( '<p>' + resp + '</p>' );
});
// this will return immediately
$.when( maybeAsync( 0 ) ).then(function( resp ) {
  $( '#target' ).append( '<p>' + resp + '</p>' );
});

#You can also pass $.when() more than one argument,
  which lets you mix sync and async operations;
  you get their return values back as arguments to the callback.

$.when( maybeAsync( 0 ), maybeAsync( 1 ) )
  .then(function( resp1, resp2 ) {
    var target = $( '#target' );
    target.append( '<p>' + resp1 + '</p>' );
    target.append( '<p>' + resp2 + '</p>' );
  });

#When a jqXHR is one of the arguments to $.when(),
  we get an array of arguments passed to our callback.

$.when( maybeAsync( 0 ), $.get( '/data/people.json' ) )
  .then(function( resp1, resp2 ) {
    console.log( "Both operations are done", resp1, resp2 );
  });