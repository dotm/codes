rustup: a command line tool for managing Rust versions and associated tools.
Cargo: Rust’s build system and package manager
Crates.io: official Rust package registry
  where Rustacean post their open source Rust projects for others to use

#Compilation
  Compile one file: rustc main.rs
  Run the file: ./main

#Using cargo
  Create new binary package         : cargo new package_name
  Create new library package        : cargo new --lib package_name
  Check if package can be compiled  : cargo check
  Compile package                   : cargo build
  Compile then run package          : cargo run
  Compile package for release       : cargo build --release
  Run all tests                     : cargo test
  Run some tests                    : cargo test substring
    The substring will match function name and module path: module_name::submodule_name::my_positive_test_case
#Arguments for cargo vs resulting binary
  Run arguments:
    cargo run --args_for_cargo_run -- --args_for_compiled_binary
    example args_for_compiled_binary: arguments for CLI tools, port number for web server binary, etc.
  Test arguments:
    cargo test --args_for_cargo_test -- --args_for_test_binary
    cargo test --help               #displays the options you can use with cargo test
    cargo test -- --help            #displays the options you can use with the test binary
    cargo test -- --test-threads=1  #run test consecutively (not in parallel)
    cargo test -- --show-output     #show stdout even for passing test
    
Use build --release for benchmarking.
Cargo may run multiple tests concurrently, so make sure that they don't race with each other.
  e.g. if they all output to a file, you should make them write to different files.

#Importing dependencies
  modify the Cargo.toml file to include the crate as a dependency
    [dependencies]
    clap = "2.27.1"                 # from crates.io
    rand = { git = "https://github.com/dotm/rand" } # from online repo
    bar = { path = "../bar" }             # from a path in the local filesystem
  run from terminal: cargo build
    Cargo fetches the latest versions of everything from the registry,
      which is a copy of data from Crates.io
    After updating the registry,
      Cargo checks the [dependencies] section and downloads any crates you don’t have yet
  add this line to a source file to import dependencies: extern crate library_name;
#Updating dependencies
  run: cargo update
    this will ignore the Cargo.lock file
    and figure out all the latest versions
    that fit your specifications in Cargo.toml.
    If that works, Cargo will write those versions to the Cargo.lock file

#Cargo.toml semver
  0.5.5 is actually shorthand for ^0.5.5, which means
    any version that has a public API compatible with version 0.5.5

#--------------------------------------------------------------------------------
// single line comment
/* multi line comment */

/// Generate library docs comment (doc string) for the following item
//! Generate library docs comment (doc string) for the enclosing item

#Operators: + - * / %
  integer division round result down: 5/9 === 0; 5.0/9.0 === 0.555
  modulo operator can't be applied to float or double
#Comparison operators: < <= > >= == !=
#Logical Operators: && || !
  && and || use short-circuit evaluation
#Bitwise Operators: & | ! ^ << >>
#Assignment Operators: += -= *= /= %= <<= >>= &= |= ^=

#--------------------------------------------------------------------------------
#Formatted print

#Macros
  format!: write formatted text to String
  print!: write formatted text to console (io::stdout)
  println!: print! appended with a newline
  eprint!: write formatted text to standard error (io::stderr)
  eprintln!: eprint! appended with a newline
#Formatted string
  #basic ({} will stringify any argument):
    println!("{} days", 31);
  #with positional argument:
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
  #with named argument:
    println!("{subject} {verb} {object}", object="a variable", subject="I", verb="am defining");
  #with special formatting:
    println!("{} of {:b} people know binary, the other half doesn't", 1, 2);
  #with right-align:
    println!("{number:>width$}", number=1, width=6);  //This will output "   1" (5 white spaces and a "1")
  #with padding (in this case with zero as padding):
    println!("{number:>0width$}", number=1, width=6)  //This will output "000001"
#Print struct:
  //add #[derive(Debug)] above the struct definition and then print like below
  println!("{:?}", struct_variable);

#Not Yet Understood??????
std::fmt contains many traits which govern the display of text. The base form of two important ones are listed below:

fmt::Debug: Uses the {:?} marker. Format text for debugging purposes.
fmt::Display: Uses the {} marker. Format text in a more elegant, user friendly fashion.
Here, we used fmt::Display because the std library provides implementations for these types. To print text for custom types, more steps are required.

Implementing the fmt::Display trait automatically implements the ToString trait which allows us to convert the type to String.

#--------------------------------------------------------------------------------
#Basic
  name variable and function with snake_case
  you can declare variable bindings first, and initialize them later.
    but it may lead to errors caused by the use of uninitialized variables.
#Statement vs. Expression
  statement ends with semicolon and will return the unit type ()
  expression doesn't end with semicolon and will return the value of it's result
#Variables vs Constant
  the type of constant value must be annotated
  constants can be declared in any scope, including the global scope
    global constant is valid for the entire time a program runs
  constants may be set only to a constant expression
    it can not be set to values computed at runtime.
#Shadowing variable
  declare a new variable using let keyword with the same name as a previous variable
  we can perform a few transformations on a value. example usecase:
    you don't need a count_str and a count variable to get count from string.
    just shadow count: let count = "number from CLI input"; let count = count.parse::<i32>().unwrap();
#Constant vs. Static
  const: An unchangeable value (the common case).
  static: A possibly mutable variable with static lifetime.
    The static lifetime is inferred and does not have to be specified.
    Accessing or modifying a mutable static variable is unsafe (need to be put inside unsafe block).
  https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md

#Constant
  const CONSTANT_NAME: TypeName = value;
  const MAX_POINTS: u32 = 100_000;
#Static
  static STATIC_NAME: TypeName = value;

#Immutable variable
  let variable_name: TypeName;
  let variable_name = value;
  let variable_name: TypeName = value;
#Mutable variable
  defining:
    let mut variable_name = value;
    let mut variable_name: TypeName = value;
  mutating:
    variable_name = value;
#Silence unused variable warning using underscore
  let _unused_variable = value;
#Initializing variable using a block
  let variable_name = {
    statements;
    expression
    //will return the value of the expression in its last line
    //if the last line is a statement, will evaluate to unit type ()
  };

#Shadowing variable
  fn main() {
    let count = "number from CLI input";
    let count = count.parse::<i32>().unwrap();
  }

#Variable reference and dereferencing (let ref, let &, &, *)
  ref on the left side of = is the same as & on the right:
    let ref reference_variable = value;
    let reference_variable = &value;
  & on the left side of = is the same as * on the right:
    let &variable_name = reference_variable;
    let variable_name = *reference_variable;

#--------------------------------------------------------------------------------
#Data Types
  #Scalar Types
    #Integer Types
      #signed: i8 i16 i32 i64 i128 isize
      #unsigned: u8 u16 u32 u64 u128 usize
      #notes:
        the number suffix indicates how many bits a type uses in the memory
          e.g. i8 uses 8 bits (1 byte)
        isize and usize types depend on the kind of computer your program is running on
          64 bits on a 64-bit architecture, 32 bits on a 32-bit architecture
          they are the same size as the pointer size of the computer counted in bit
        default integer type is i32
        integer (except byte literal) can be separated with underscore: 100_000
        integer can overflow. check this to see how to handle it with built in methods:
          wrapping_* checked_* overflowing_* saturating_*
          https://doc.rust-lang.org/book/ch03-02-data-types.html
      #example literals:
        Decimal         98_222
        Hex             0xff
        Octal           0o77
        Binary          0b1111_0000
        Byte (u8 only)  b'A'
      #using suffix annotation to define integer size:
        let an_int = 100i16; //can also be 100_i16, 100u128, 100u_128, etc.
    #Floating-Point Types: f32 f64
      default type: f64
      example literals: 3.14 1e5 1e+5 1e-3 1_000.10
      using suffix annotation: 3.14f32 1e5_f32
    #Boolean Type: bool
      #value: true false
    #Character Type: char
      notes:
        four bytes in size
        represents a Unicode Scalar Value (it can represent a lot more than just ASCII)
        Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive
      example literals: 'a' 'ℤ' '😻'
    #Unit type is the empty tuple: ()
  #Compound Types
    #Primitive Compound Types: tuple, array
    #Custom Types: struct, enum

#Type Casting (Type Conversion)
  #using the as keyword: variable_name as TypeName
  #using the std::convert::From trait
    #definition
      struct Number {
        value: i32,
      }
      impl From<i32> for Number {
        fn from(item: i32) -> Self {  //Self in this context is Number
          Number { value: item }
        }
      }
    #usage:
      Number::from(30)
  #using std::convert::Into
    #definition
      struct Wrapper<T>(Vec<T>);
      impl<T> Into<Vec<T>> for Wrapper<T> {
        fn into(self) -> Vec<T> {
          self.0
        }
      }
    #usage
      let vector: Vec = wrapper.into(); //type annotation is required
  #using the std::convert::TryFrom trait
    #definition
      #[derive(Debug, PartialEq)]
      struct EvenNumber(i32);
      impl TryFrom<i32> for EvenNumber {
        type Error = ();
        fn try_from(value: i32) -> Result<Self, Self::Error> {
          if value % 2 == 0 {
            Ok(EvenNumber(value))
          } else {
            Err(())
          }
        }
      }
    #usage:
      EvenNumber::try_from(8)
  #using the std::convert::TryInto trait
    #definition
      just define TryFrom and you'll get TryInto for free
    #usage
      let result: Result<EvenNumber, ()> = 8i32.try_into();
#Notes for From and Into
  if you have define the From trait, you'll get the Into trait for free.
    so you should prefer to use From over using Into.
  implement Into if a conversion to a type outside the current crate is required.
    in older version of Rust, From cannot do these type of conversions because of Rust's orphaning rules.
  Prefer using Into over using From when specifying trait bounds on a generic function.
    This way, types that directly implement Into can be used as arguments as well.

#Get the size of value: std::mem::size_of_val

#Type Alias: type NewTypeName = TypeName;
  The type statement can be used to give a new name to an existing type.
  Type Alias doesn't create new type and so it doesn't provide any extra type safety.
    type NanoSecond = u64; type Inch = u64;
    you can add NanoSecond to Inch and the compiler won't complain.
  Types must have UpperCamelCase names, or the compiler will raise a warning.
    The exception to this rule are the primitive types: usize, f32.
    You can use this attribute to silence the warning:
      #[allow(non_camel_case_types)]
      type u64_t = u64;
  You can use type alias with generics: type IoResult<T> = Result<T, IoError>;

#--------------------------------------------------------------------------------
#Conditional

#If-else expressions
  all branches must return the same type
  if statement is if-else expression that returns ()
#If statement
  if condition { statements; } else if condition { statements; } else { statements; }
#If expression
  if condition { expression } else if condition { expression } else { expression }
#Inline if expression (equivalent to ternary): let variable_name = if condition { value } else { value };

#Conditional compilation
  #using the cfg attribute:
    #[cfg(target_os = "linux")]
    fn function_name() {} //this function only gets compiled if the target OS is linux
    #[cfg(not(target_os = "linux"))]
    fn function_name() {} //this function only gets compiled if the target OS is not linux
  #using the cfg! macro:
    if cfg!(target_os = "linux") {
      println!("Yes. It's definitely linux!");
    } else {
      println!("Yes. It's definitely *not* linux!");
    }
#Custom conditional compilation
  !custom.rs
    #[cfg(some_condition)]
    fn conditional_function() {}
    fn main() {
      conditional_function();
    }
  from cli, run:
    rustc --cfg some_condition custom.rs

#--------------------------------------------------------------------------------
Loop

#Infinite loop
  loop { statement; break }
  let variable_name = loop { statement; break expression }

#While loop
  while condition { statement; }

#For in loop
  for number in 1..4 { println!("{}!", number); }     // will print: 1, 2, 3
  for number in 1..=4 { println!("{}!", number); }    // will print: 1, 2, 3, 4
  for number in (1..4).rev() { println!("{}!", number); } // will print: 3, 2, 1
#iterating over array:
  for element in array_name { statement; }
  for index in 0..array_name.len() { statement; }
  for (index, element) in array_name.iter().enumerate() { statement; }   //with pattern matching to destructure tuple
#For in with Iterator trait
  into_iter, iter, and iter_mut
    all handle the conversion of a collection
    into an iterator in different ways,
    by providing different views on the data within.
  by default the for loop will apply
    the into_iter function to the supplied collection.
#iter: will borrow each element
  for name in names.iter() {
    match name {
      &"Ferris" => println!("There is a rustacean among us!"),
      _ => println!("Hello {}", name),
    }
  }
#into_iter: will consume/move each element (making the original collection unusable)
  for name in names.into_iter() {
    match name {
      "Ferris" => println!("There is a rustacean among us!"),
      _ => println!("Hello {}", name),
    }
  }
#iter_mut: will mutably borrows each element (allowing for the collection to be modified in place)
  for name in names.iter_mut() {
    *name = match name {    //modifying element by dereferencing
      &mut "Ferris" => "There is a rustacean among us!",
      _ => "Hello",
    }
  }

#Control Transfer Statements for Loop
  continue
  break
  break expression;     //break and return value from a loop (semicolon is optional)
#Labels
  'outer: loop {      //labels start with '
    'inner: loop {
      break 'outer;   //break to label (you can also continue to label)
    }
  }

#--------------------------------------------------------------------------------
#Function
  first-class citizen
  is not closure (can not capture the enclosing environment)
    use Lambda expression instead
#Definition
  #basic: fn function_name(){ statements; }
  #with return value:
    #explicit return: fn function_name() -> TypeName { return value }
    #implicit return: fn function_name() -> TypeName { expression }
    #notes:
      don't use semicolon when returning
      void return type can be optionally represented using empty tuple ()
  #with multiple return value
    #using tuple: fn function_name() -> (TypeName, TypeName, ...) { return (value, value, ...) }
  #with parameter: fn function_name(parameter_name: TypeName, parameter_name: TypeName){ statements; }
#Call
  #basic: function_name()
  #with parameter: function_name(value, value)
  #ignoring return value: let _ = function_name()
#Nested function:
  fn a(){ b(); fn b(){ statements; } }

#--------------------------------------------------------------------------------
#Lambda expression
  Closures in Rust (lambda expressions or lambdas) are functions that can capture the enclosing environment.
  Closure of a single expression doesn't need to use body delimination ({})
#Definition
  let closure_annotated = |x: i32, y: i32| -> i32 { x + y };
  let closure_inferred  = |i| i + 1  ;
  let closure_with_no_parameter = || 1;
#Call
  closure_annotated(3,4)
  closure_inferred(3)
  closure_with_no_parameter()
#Immediately Invoked Closure
  (|| println!("hello"))();

#Closure memory management (for heap data)
  Closures can automatically capture variables in the heap:
    by reference: &T
    by mutable reference: &mut T
    by value: T
  They preferentially capture variables by reference and only go lower when required.
  Using move before vertical pipes forces closure to take ownership of captured variables
#Example (all variables below exist in the heap)
  #borrow an immutable reference:
    let print = || println!("{}", immutable_variable);
  #borrow a mutable reference:
    let mut inc = || mutable_variable += 1;
      a `let mut` is required because a `&mut` is stored inside
      calling the closure mutates the closure which requires a `mut`
  #move variable:
    let consume = || mem::drop(variable_name);
    let contains = move || println!("{}", variable_name);   //this will move variable_name manually

#--------------------------------------------------------------------------------
#Rust Memory Management
  Rust does not use manual memory management or Garbage Collection
    which causes runtime delay when the GC run.
  Rust automatically return heap memory to the heap manager
    by calling the `drop` function once the variable that owns it goes out of scope.
  In Rust:
    types with Copy trait is stored in the stack
      including: scalar values, tuple which contains only Copy type
    types with Drop trait can't also be Copy
      Drop trait is for types that need something special to happen when the value goes out of scope

#Ownership Rules
  Each value in Rust has a variable that’s called its owner
  There can only be one owner at a time
  When the owner goes out of scope, the value will be dropped

#Heap deallocation inside a scope
  {
    //the s1 below will point to a string on the heap
    let s1 = String::from("hello"); //s1 is valid from this point forward
    //do stuff with s1
  } //this scope is now over. s1 is dropped and no longer valid
#Moving heap data to another variable
  {
    let s1 = String::from("hello");
    let s2 = s1;
    //s2 is NOT a shallow copy of the String type (pointer, length, capacity) in s1
    //instead the data of s1 is moved into s2 and s1 is no longer valid (not accessible)

    println!("{}, world!", s1); //will raise "borrow of moved value" error
  } //only s2 will be dropped, because s1 is no longer valid
#Copying heap data
  {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    //clone will perform a deep copy of s1 (NOT a shallow copy)
    //  a new memory will be allocated in the heap and filled with the same value as s1

    println!("s1 = {}, s2 = {}", s1, s2); //will not raise error
  }
#Stack data is automatically copied
  {
    let x = 5;
    let y = x; //y will contain a new copy of 5 (a new memory will be created in the stack)
    println!("x = {}, y = {}", x, y);   //will not raise error
  }
#Passing data to a function parameter
  same semantic as assigning to another variable:
    heap data will be moved (transfer the ownership to function parameter)
    stack data will be copied to function parameter
#Returning data from a function
  same semantic as assigning to another variable
    heap data will be moved
      (transfer the ownership out of the function to the variable that will contain the return value)
    stack data will be copied

#Borrowing using reference
  #Borrowing value with immutable reference
    fn calculate_length(s: &String) -> usize {
      s.len() //s here is NOT a shallow copy of s1 String type data (it doesn't point directly to the heap). s is just a pointer to s1.
    }         //s is not dropped because it doesn't have ownership of the borrowed String type
    let s1 = String::from("hello");
    let len = calculate_length(&s1); //creating the reference
  #Borrowing value with mutable reference
    fn change(some_string: &mut String) {
      some_string.push_str(", world");    //if we use immutable reference, this line will raise compile error
    }
    let mut s = String::from("hello");
    change(&mut s); //creating the reference

#References Rules
  At any given time, you can have either one mutable reference or any number of immutable references
  References must always be valid (no dangling reference allowed)
    fn dangle() -> &String {  //this will raise "missing lifetime specifier" compile error
      let s = String::from("hello");
      &s  //we return a reference to the String s
    }     //but s goes out of scope here and is dropped
    let reference_to_nothing = dangle(); //will raise compile error

#--------------------------------------------------------------------------------
#Tuple
  fixed length and type after definition
  heterogenous type
  zero index
  tuple can contain other tuples
#Definition:
  let tuple_name: (TypeName, TypeName) = (value, value);
  let tuple_name: (i32, f64, u8) = (500, 6.4, 1);
#One element tuple:
  let tuple_name: (TypeName,) = (value,);
  let tuple_name: (i32,) = (500,);
#Pattern matching for destructuring tuple:
  let (x, y, z) = tuple_name;
  let (_, _, z) = tuple_name; //ignoring the first two values
#Access by index:
  tuple_name.index_number
  tuple_name.0  //first element
  tuple_name.1  //second element

#--------------------------------------------------------------------------------
#Array
  fixed length and type after definition, homogenous type, zero index
  Arrays are useful when
    you want your data allocated on the stack rather than the heap
    or when you want to ensure you always have a fixed number of elements
      (use vector type if you want a variable-length collection)
  If you try to access an element of an array that is past the end of the array,
    the program resulted in a runtime error and didn’t exit successfully
    (Rust will panic).
#Definition
  #with type annotation: let array_name: [TypeName; array_length] = [value, value, value];
  #with type annotation: let array_name: [i32; 3] = [7,7,7];
  #without type annotation: let array_name = [value, value, value];
  #without type annotation: let array_name = [7,7,7];
  #with repeating syntax: let array_name = [value; array_length];
  #with repeating syntax: let array_name = [7; 3];
#Access by index
  array_name[index_number]
  array_name[0]        //first element
#get array length: array_name.len()

#--------------------------------------------------------------------------------
#Slice
  is a reference to a contiguous sequence of elements in a collection
  follows the References Rules since it is a reference
  String slice range indices must occur at valid UTF-8 character boundaries.
    If you attempt to create a string slice
    in the middle of a multibyte character,
    your program will exit with an error.
  is a two-word object
    the first word is a pointer to the data
    and the second word is the length of the slice
  in the case of `let slice_name = &s[6..11];`
    slice_name would be a slice that contains
      a pointer to the 7th byte (counting from 1) of s
      a length value of 5
  word size is the same as usize, determined by the processor architecture
  slices can be used to borrow a section of an array of type T, and have the type signature &[T].
#create
  #from array or string:
    let slice_name = &array_name[starting_index..ending_index]
    let slice_name = &array_name[1..3]  //will include elements of index 1 and 2 from array_name
    let slice_name = &array_name[1:]  //will include elements from index 1 until the last element from array_name
    let slice_name = &array_name[:3]  //will include elements of index 0, 1, and 2 from array_name
    let slice_name = &array_name[:]   //will include all elements from array_name
  #get slice length: slice_name.len()
#passing whole array as slice:
  let array_name: [T; array_length] = [];
  fn function_name(slice_name: &[T])
  function_name(&array_name[..])      //can be done like this
  function_name(&array_name)        //can also be done like this

#--------------------------------------------------------------------------------
#String
  A String type is a wrapper over a Vec<u8>
  3 relevant ways to look at strings (e.g. "नमस्ते") from Rust’s perspective:
    bytes: [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
    scalar values: ['न', 'म', 'स', '्', 'त', 'े']
    grapheme clusters: ["न", "म", "स्", "ते"]
  Rust doesn't allow string to be accessed by index (e.g. str[0])
#String Type vs string literal
  A string literal lives on the stack because it's immutable.
    The text is hardcoded directly into the final executable.
  A String type lives on the heap because it's mutable.
    Creating String Type will request heap memory from the OS.
  string literals are stored inside the binary (in the data segment)
    in `let variable_name = "hello";`
      what is inside variable_name is actually
        a slice (with start index and length data)
        pointing to a specific point of the binary
      which is why variable_name
        have the type &str (because a slice is a reference and reference type starts with &)
        and is immutable (because the &str is actually an immutable reference)
  A String type is made up of three parts:
    a pointer to the heap memory that holds the contents of the string
    a length: how much memory, in bytes, the contents of the String is currently using
    a capacity: the total amount of memory, in bytes, that the String has received from the operating system
#Creating String Type
  let mut s = String::new();
  let s = data.to_string();   //see Convert any type to String type
  let s = String::from("string literal");
#Concatenating String
  #using push_str:
    let mut s = String::from("hello ");
    s.push_str("world");
  #using push:
    let mut s = String::from("a");
    s.push('b');      //only accept 1 character
  #using + operator:
    let s1 = String::from("hello ");  //s1 will be moved by +
    let s2 = String::from("world");   //s2 is used by + as a borrowed reference
    let s3 = s1 + &s2;                //note the &
  #using format! macro:
    let s = format!("{}-{}-{}", s1, s2, s3);  //s1, s2, s3 are all borrowed
#Slicing string
    let non_utf8_string = "Здравствуйте"; //each of these char takes two u8
    let s = &non_utf8_string[0..4];       //"Зд"
  Using ranges to create string slices can crash your program
    let s = &non_utf8_string[0..1];       //will panic because the char boundary is at range 0..2
#Iterating over String
  for c in "नमस्ते".chars() { println!("{}", c); }  //will print the scalar values: ['न', 'म', 'स', '्', 'त', 'े']
  for b in "नमस्ते".bytes() { println!("{}", b); }  //will print the bytes: [224, 164, 168, 224, ...]
  use crate from Crates.io if you want to iterate over grapheme clusters

#Convert any type to String type
  To convert to String, the type need to implement the ToString trait.
  Rather than doing so directly, you should implement the fmt::Display trait
    which automagically provides ToString and also
    allows printing the type using print! and other such macros
#Example
  use std::fmt;
  struct Circle { radius: i32 }
  impl fmt::Display for Circle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
      write!(f, "Circle of radius {}", self.radius)
    }
  }
  fn main() {
    println!("{}", (Circle { radius: 6 }).to_string());
  }

#Convert string to number (parsing string)
  The idiomatic approach to this is to use the parse function and
    either to arrange for type inference
    or to specify the type to parse using the 'turbofish' syntax.
  This will convert the string into the type specified
    so long as the FromStr trait is implemented for that type.
#Parse function
  #with type inference
    let parsed: i32 = "5".parse().unwrap();
  #with turbofish syntax
    let turbo_parsed = "10".parse::<i32>().unwrap();

#String slices as parameter
  instead of declaring a function like this:
    fn get_first_word(s: &String) -> &str
  it's better to declare it like this:
    fn get_first_word(s: &str) -> &str
  this is for performance reason:
    with the first function signature, you can only pass string literal &str
      by putting it inside the heap first (expensive):
        let string_literal = "hello world";
        let word = get_first_word(&String::from(string_literal));
    with the second signature,
      you can pass the string literal directly:
        get_first_word(string_literal)
      but you can also pass String type easily:
        get_first_word(&a_string_type[..]);
      because Rust uses a deref coercion, it automatically turns &a_string_type into &a_string_type[..]
        get_first_word(&a_string_type);

#--------------------------------------------------------------------------------
#Collections std::collections
  the data these collections point to is stored on the heap
    the amount of data does not need to be known at compile time
    and can grow or shrink as the program runs
  common collections: String Vec HashMap

#Vector
  variable length but fixed type after definition, homogenous type, zero index
  when the vector gets dropped (when it get goes out of scope), all of its contents are also dropped
#Definition
  let vector_variable: Vec<i32> = Vec::new();
  let vector_variable = vec![1, 2, 3];
#Vector methods
  #pushing to vector:
    let mut vector_variable = Vec::new(); //mut is required
    vector_variable.push(5);              //this will create a mutable reference to vector_variable
#Accessing vector elements
  #by index: let first: &i32 = &v[0];     //will panic if index is out of range
  #by get method:
    match v.get(0) {            //won't panic if index is out of range
      Some(first) => print!("{}", first),
      None => (),
    }
#Iterating over vector elements
  for element in &vector_variable { println!("{}", element); }
  for element in &mut vector_variable { *element += 1 }
#Storing heterogenous type
  #using enum:
    enum SpreadsheetCell { Int(i32), Float(f64) }
    let row = vec![SpreadsheetCell::Int(3), SpreadsheetCell::Float(10.12)];
  #using trait

#HashMap (a.k.a. hash, map, object, hash table, dictionary, or associative array)
  homogeneous (keys must be of the same type, value must be of the same type)
  HashMap ownership:
    for types that implement the Copy trait, like i32, the values are copied into the hash map.
    for owned values like String, the values will be moved and the hash map will be the owner of those values
    if we insert references to values into the hash map, the values won’t be moved into the hash map.
      the values that the references point to must be valid
      for at least as long as the hash map is valid (see lifetime specifier)
#Definition
  use std::collections::HashMap;
  let mut hashmap = HashMap::new();
#Insert element: hashmap.insert(key, value)
#Access value by key:
  //the & in &key below is mandatory
  //get returns an Option<&V>
  match hashmap.get(&key) {
    Some(value) => println!("{}",value),
    None => (),
  }
  if let Some(value) = hashmap.get(&key) {
    println!("{}",value)
  }
#Iterating over HashMap
  for (key, value) in &hashmap {
    println!("{}: {}", key, value);
  }
#Updating HashMap
  #replace old value with new value:
    hashmap.insert(1, 10);
    hashmap.insert(1, 25);  //hashmap with key 1 will now have a value of 25
  #only insert if no value exist for a key:
    hashmap.entry(key).or_insert(value);
  #update value based on old value:
    fn count_chars(s: &str) -> HashMap<char,i32> {
      let mut hashmap = HashMap::new();
      for c in s.chars() {
        let count = hashmap.entry(c).or_insert(0);
        *count += 1;
      }
      hashmap
    }

#--------------------------------------------------------------------------------
#Struct: a collection of fields
  #declaration:
    #basic struct:
      struct StructName {
        field_name1: TypeName,
        field_name2: TypeName,
      }
    #tuple struct (named tuples):
      struct StructName(TypeName, TypeName);
    #unit struct (field-less; useful for generics):
      struct StructName;
  #instantiate struct:
    #basic struct:
      let struct_variable = StructName {
        //the fields below doesn't need to be ordered exactly as the definition
        field_name1: value,
        field_name2: value,
      }
    #tuple struct:
      let struct_variable = StructName(value, value);
    #unit struct:
      let struct_variable = StructName;
  #access field:
    #basic struct: struct_variable.field_name1
    #tuple struct: struct_variable.index    //e.g. struct_variable.0 for the first element
  #change field value of mutable struct:
    struct_variable.field_name1 = value
  #destructuring using let binding:
    #basic struct:
      let StructName {field_name1: x, field_name2: y} = struct_variable;
    #tuple struct:
      let StructName(x, y) = struct_variable;
#Using field init shorthand in struct factory
  fn build_struct(field_name1: TypeName) -> StructName {
    StructName {
      field_name1, //field init auto-set this using argument/variable with the same name
      field_name2: value,
    }
  }
#Using struct update syntax
  let struct_variable = StructName {
    field_name1: value,
    ..another_struct   //fields other than field_name1 are set to the corresponding value of another_struct
  }
#Ownership of Struct Data
  struct User {
    username: String,
    //we usually use the owned String type in struct
    //so this struct's instances own all of its data
    //and for that data to be valid for as long as the entire struct is valid.

    email: &'static str,
    //it’s possible for structs to store references to data owned by something else
    //but to do so requires the use of lifetime specifiers
  }

#Using struct to enforce validation of contract
  Having lots of error checks in all of your functions would be verbose and annoying.
    Fortunately, you can use Rust’s type system to do many of the checks for you.
      e.g. using unsigned integer, you can enforce that something should never have negative value.
    You can also create custom type to add stricter contract.
#Example:
  pub struct TestScore { value: i32 }       //value is private so that it cannot be set arbitrarily
  impl TestScore {
    pub fn new(value: i32) -> TestScore {
      let mut t = TestScore{value:0};
      t.set_value(value);
      t
    }
    pub fn set_value(&mut self, value: i32) {   //setter allows validation before mutation
      if value < 1 || value > 100 {
        panic!("enforce that value must be between 1 and 100, got {}.", value);
      }
      self.value = value
    }
    pub fn value(&self) -> i32 {        //getter must be provided so that private value can be accessed
      self.value
    }
  }
#--------------------------------------------------------------------------------
#Impl block
  impl block can be used to define method and associated function
  one item (struct, enum, or a trait object) can have multiple impl block

#Associated Functions (static method)
  are functions within impl blocks that don’t take self as a parameter
  are associated with an item
  are often used for constructors that will return a new instance of a struct
#Definition
  impl Item {
    fn function_name(){ statement; }
  }
#Call
  Item::function_name()

#Method
  is function that is defined within
    the context of an item (literal value, struct, enum, or a trait object)
    by using an impl block
  first parameter is always self
    which represents the instance of the item the method is being called on
#Definition
  impl Item {
    //borrow using immutable reference
    fn get_data(&self) -> TypeName { self.data; } //&self is shorthand for self: &Self
    //borrow using mutable reference
    fn mutate_data(&mut self){ self.data = value; }
    //takes ownership of the item
    fn takes_ownership(self) -> TypeName {
      //done with operation that renders the calling item invalid
      return value;
    }
  }
#Call: item.method()
  Rust has automatic referencing and dereferencing
  e.g. you don't have to do (&item).get_data() or (&mut item).mutate_data()

#Method on literal value and expression
  value.method()
    "string literal".to_string()
  (expression).method()
    (-9_i32).abs()

#--------------------------------------------------------------------------------
#Enumeration
  enum is a type that can have a fixed set of values
    those values are called the enum’s variants
  Rust’s enums are most similar to algebraic data types (tagged union) in functional languages
#Definition
  enum WebEvent {
    PageLoad,                 //unit-like enum value
    KeyPress(char),           //tuple struct enum value
    Click { x: i64, y: i64 }, //struct enum value
  }
#Instantiate
  #basic:
    let pressed = WebEvent::KeyPress('x');
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load  = WebEvent::PageLoad;
  #import with use declaration:
    use crate::WebEvent::{PageLoad, KeyPress};  //use some enum value
    use crate::WebEvent::*;                     //use all enum value
    let load = PageLoad;                        //no longer need to prefix this with WebEvent::
#Pattern matching enum (see Pattern Matching for more detail)
  #using match
    fn handleWebEvent(event: WebEvent){
      match event {
        //single line match arm expression
          WebEvent::PageLoad => println!("page loaded"),
        //bind value (destructure) to c
          WebEvent::KeyPress(c) => println!("pressed '{}'.", c),
        //bind value (destructure) of Click into x and y
          WebEvent::Click { x, y } => {
            //use {} for multiple lines match arm code
            println!("clicked at x={}, y={}.", x, y);
          },
        //default case
          _ => println!("other event"),
      }
    }
  #using if let
    if let WebEvent::KeyPress(key) = variable_name {
      println!("user press {}",key);
    } else {
      println!("default case for all other events");
    }
#Define Method for Enumeration
  #Definition:
    impl WebEvent {
      fn call(&self) {
        statement;
      }
    }
  #Call:
    WebEvent::KeyPress('x').call();

#--------------------------------------------------------------------------------
#Common Monad

#Option Enum
  Option enum is included in the prelude (no need of import or prefix)
#Definition
  enum Option<T> { Some(T), None }
#Use:
  let some_number = Some(5);
  let some_string = Some("a string");
  let absent_number: Option<i32> = None;  //you must add type annotation to define the T
#Pattern matching Option enum
  fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
      None => None,
      Some(i) => Some(i + 1),
    }
  }
#Map using the map combinator
  let out: Option<i32> = option_u32.map(|value| value as i32);
#Flatmap using the and_then combinator (for when the function also return Option)
  let out: Option<i32> = option_u32.and_then(|value| Some(value as i32));

#Result Enum
  Result enum is also included in the prelude
  Result also have map and and_then (flat map) combinator
#Definition
  enum Result<T,E> {
    Ok(T)
    Err(E)
  }
#Result as main function return value
  fn main() -> Result<(), ParseIntError> {}
  fn main() -> Result<(), Box<dyn Error>> {
#Result alias idiom
  type AliasedResult<T> = Result<T, SomeError>;
  //example: io::Result is an alias for Result<T, IoError>
#Iterating over Result
  #note:
    an Iter::map operation might fail
      let strings = vec!["tofu", "93", "18"];
      let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())  //will fail when parsing tofu
        .collect();
      //Results: [Err(ParseIntError { kind: InvalidDigit }), Ok(93), Ok(18)]
    and there are strategies for handling this
    we can use the strategies here for Option too
  #Ignore the failed items with filter_map()
    let numbers: Vec<_> = strings
      .into_iter()
      .map(|s| s.parse::<i32>()).filter_map(Result::ok)
      .collect();
    //Results: [93, 18]
  #Fail the entire operation with collect()
    let numbers: Result<Vec<_>, _> = strings
      .into_iter()
      .map(|s| s.parse::<i32>())
      .collect();
    //note: Result implements FromIter so that a vector of results (Vec<Result<T, E>>)
    //  can be turned into a result with a vector (Result<Vec<T>, E>).
    //  Once an Result::Err is found, the iteration will terminate.
  #Collect all valid values and failures with partition()
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
      .into_iter()
      .map(|s| s.parse::<i32>()).partition(Result::is_ok);
    //Numbers: [Ok(93), Ok(18)]
    //Errors: [Err(ParseIntError { kind: InvalidDigit })]
  #Collect and unwrap all valid values and failures with partition()
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
      .into_iter()
      .map(|s| s.parse::<i32>()).partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    //Numbers: [93, 18]
    //Errors: [ParseIntError { kind: InvalidDigit }]


#Interaction between different Option and Result types
  Sometimes an Option needs to interact with a Result,
    or a Result<T, Error1> needs to interact with a Result<T, Error2>.
    In those cases, we want to manage our different error types
    in a way that makes them composable and easy to interact with.
#Embedding
  #note: the most basic way of handling mixed error types is to just embed them in each other
  #example:
    fn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> { //embed Result inside Option
      vec.first().map(|first| { first.parse::<i32>().map(|n| 2 * n) })
    }
#Pulling Result out of Option
  #example:
    fn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
      let opt = vec.first().map(|first| { first.parse::<i32>().map(|n| 2 * n) });
      opt.map_or(Ok(None), |r| r.map(Some))
    }
#Defining an error type??? (TODO)
  Sometimes it simplifies the code to mask all of the different errors with a single type of error.

#--------------------------------------------------------------------------------
#Pattern Matching
  Use if let statement if you feel pattern matching is unnecessary

#Match Expression
  Match is an expression
    it can evaluate into a value
  A match expression is made up of arms
    its arms must have the same return type
  An arm consists of
    a pattern
    and the code that should be run if the value given to the beginning of the match expression fits that arm’s pattern
  Match must have collectively exhaustive patterns in its arms (or Rust will throw compile error)
  You can return early in a function from its match expression
    If you have a nested match expression,
    you might be able to simplify it using early return
#Example
  let some_u8_value = 0u8;
  match some_u8_value {
    1 => println!("One!"),                //match a single value
    2 | 3 | 5 | 7 | 11 => println!("This is a prime"),  //match several values
    13..=19 => println!("A teen"),            //match an inclusive range
    100 => {                      //you can run multiple lines of code using curly brackets
      println!("A hundred")
      println!("A hundred!!!")
    },
    _ => (),                      //this will do nothing (it'll only return the unit type value)
  }
#Example of Early Return
  fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");
    let mut f = match f {       //the result of match evaluates to a value
      Ok(file) => file,
      Err(e) => return Err(e),  //you can return early from a match expression
    };
    let mut s = String::new();
    match f.read_to_string(&mut s) {
      Ok(_) => Ok(s),
      Err(e) => Err(e),
    }
  }

#Using match to destructure
  #tuple
    let point = (0, -2);
    match point {
      (0, y) => println!("point is in x line'),   //will match any point with x == 0
      (x, 0) => println!("point is in y line"),
      _    => println!("point is elsewhere"),   // `_` means don't bind the value to a variable
    }
  #enum
    see Pattern matching enum for example
  #pointer (reference)
    let reference: &i32 = &4;
    match reference {
      &val => println!("val is of type i32"),
    }
    match *reference {
      val => println!("val is of type i32"),
    }
    let value = 5;
    match value {
      ref r => println!("r is of type &i32"), //use ref keyword to create a reference.
    }
    let mut mut_value = 6;
    match mut_value {
      ref mut m => {  //use ref mut keyword to create a mutable reference
        *m += 10;   //mutate by dereferencing it first
      },
    }
  #struct
    struct Foo {
      x: (u32, u32),
      y: u32,
    }
    match foo {
      Foo { x: (1, b), y } => println!("First of x is 1, b = {},  y = {} ", b, y),

      // you can destructure structs and rename the variables,
      // the order is not important
      Foo { y: 2, x: i } => println!("y is 2, i = {:?}", i),

      // and you can also ignore some variables:
      Foo { y, .. } => println!("y = {}, we don't care about x", y),
      // you can't ignore variables like this. it will give an error: pattern does not mention field `x`
      //Foo { y } => println!("y = {}", y);
    }

#Guard
  let pair = (2, -2);
  match pair {
    (x, y) if x == y => println!("Twins"),      // The `if condition` part is a guard
    (x, y) if x + y == 0 => println!("Antimatter"),
    (x, _) if x % 2 == 1 => println!("The first one is odd"),
    _ => println!("No correlation..."),
  }

#If let statement
  if let value = variable_name {      //read: if let destructure variable_name into value, then do statement
    statement;
  } else if let value = variable_name {
    statement;
  } else if condition {
    statement;
  } else {
    statement;
  }
#Example
  if let WebEvent::KeyPress(key) = variable_name {
    println!("variable_name matches KeyPress with parameter value {}",key);
  } else if let 3 = some_u8_value {
    println!("is three");
  } else if some_u8_value % 2 == 0 {
    println!("is even");
  } else {
    println!("not three");
  }

#While let statement
  let mut optional = Some(0);
  //while `let` destructures `optional` into `Some(i)`, evaluate the block, else break out of loop
  while let Some(i) = optional {
    if i > 9 {
      optional = None;  //quit
    } else {
      optional = Some(i + 1);
    }
  }

#--------------------------------------------------------------------------------
#Code Organization
  Rust's module system features:
    Packages: A Cargo feature that lets you build, test, and share crates
    Crates: A tree of modules that produces a library or executable
    Modules and use: Let you control the organization, scope, and privacy of paths
    Paths: A way of naming an item, such as a struct, function, or module

#Package: one or more crates that provide a set of functionality
  package
    is what get built when you run cargo new
    contains a Cargo.toml file that describes how to build those crates
    must contain at least one crate (library or binary)
    can contain zero or one library crate
    can contain as many binary crates as you want
  If a package contains src/main.rs and src/lib.rs, it has two crates:
    a binary and a library, both with the same name as the package.
  A package can have multiple binary crates by placing files in the src/bin directory.
    Each file will be a separate binary crate.
    To compile or run src/bin/my_other_bin binary as opposed to the default binaries,
      pass cargo the `--bin my_other_bin` flag

#Crate: a collection of Rust source code files
  A crate can be compiled into a binary or into a library.
    binary crate is executable
    library crate contains code intended to be used in other programs
  a crate group related functionality together in a scope to make them easy to share between projects
  a crate’s functionality is namespaced in its own scope (crate_name::functionality)
#Crate root: a source file that the Rust compiler starts from and makes up the root module of your crate
  src/main.rs
    is the crate root of a binary crate with the same name as the package
  src/lib.rs
    is the crate root of a library crate with the same name as the package
  Cargo passes the crate root files to rustc to build the library or binary.
#Crate compilation
  A crate is a compilation unit in Rust.
    modules do not get compiled individually, only crates get compiled.
  Whenever rustc some_file.rs is called,
    some_file.rs is treated as the crate file.
  If some_file.rs has mod declarations in it,
    then the contents of the module files would be inserted
    in places where mod declarations in the crate file are found,
    before running the compiler over it.

#Creating library crate: rustc --crate-type=lib library_name.rs
  This will create a library_name.rlib in the lib directory
  The name of the library can be specified manually by overriding the crate_name attribute.
#Import library crate:
  In the importing file, add this line:
    extern crate library_name;
  notes:
    the extern crate declaration will not only link the library,
    but also import all its items under a module named the same as the library.
    The visibility rules that apply to modules also apply to libraries.
  When compiling the importing crate, add the extern flag:
    rustc executable.rs --extern library_name=path/to/library_name.rlib

#Module tree
  the contents of either of the crate root file
    form a module named `crate`
    at the root of the crate’s module structure,
    known as the module tree.
  the entire module tree is rooted under the implicit module named crate.
#Module: a collection of items (usually placed inside one directory)
  Inside modules, we can have items such as:
    other modules, structs, methods, enums, constants, traits, or functions.
  Modules control the privacy of items, i.e.
    whether an item can be used by outside code (public)
    or is an internal implementation detail and not available for outside use (private).
  Rust visibility rules (the way privacy works in Rust):
    - all items are private by default
    - item in one module can use all the other (public and private) items in the same module
    - items in a parent module can’t use the private items inside child modules
    - items in child modules can use the private items in their ancestor modules
    - private parent items will still restrict the visibility of its child item
      even if the child item is declared as visible/public within a bigger scope.
#Example
  mod parent_module {             //parent_module is private
    const CONSTANT_NAME: type = value;

    pub mod child_module {          //use the pub keyword to make an item public
      pub fn public_function() {
        private_function()        //can access other items in the same module even when private
      }
      fn private_function() {}
    }

    pub mod sibling_module {
      pub struct StructName {   //will make the struct public, but the struct’s fields will still be private.
        pub public_field: type, //we can make each field public or not on a case-by-case basis
        private_field: type,
      }
      impl StructName {               //struct with private fields can't be instantiated the normal way.
        pub fn new() -> StructName {  //it needs a public associated function
          StructName {                //  that constructs an instance of itself.
            public_field: value,      //This constructor is usually named as `new`
            private_field: value,     //  and is called with StructName::new()
          }
        }
      }

      pub enum EnumName {   //pub will make an enum and all of its variants public
        variant1
        variant2
      }
    }
  }
#The example above will create the module tree:
  crate
   └── parent_module
      ├── CONSTANT_NAME
      ├── child_module
      │  ├── public_function
      │  └── private_function
      └── sibling_module
         ├── StructName
         └── EnumName
#Separating modules into multiple files
  !src/lib.rs
    mod parent_module;
  !src/parent_module.rs or !src/parent_module/mod.rs
    const CONSTANT_NAME: type = value;
    mod child_module;
    mod sibling_module;
  !src/parent_module/child_module.rs or !src/parent_module/child_module/mod.rs
    pub fn public_function() {}
    fn private_function() {}
  !src/parent_module/sibling_module.rs or !src/parent_module/sibling_module/mod.rs
    pub struct StructName {}
    pub enum EnumName {}
#Pub modifier variations
  #default: make the item visible everywhere
    pub fn function_name() {}
  #pub in path: make the item visible within the given path (`path` must be a parent or ancestor module)
    pub(in crate::parent_module) fn function_name() {}
  #pub self: is the same as just declaring an item as private (is visible in self only)
    pub(self) fn function_name() {}
  #pub super: make the item visible within its immediate parent module only
    pub(super) fn function_name() {}
  #pub crate: make the item visible only within the current crate
    pub(crate) fn function_name() {}

#Path: show Rust where to find an item in a module tree (just like filesystem's path)
  Absolute vs Relative paths
    absolute path starts from a crate root by using a crate name or a literal crate keyword.
      crate::parent_module::child_module::public_function()
    relative path starts from the current module and uses self, super, or an identifier in the current module.
      if we are in parent_module.rs, we can use both of these paths:
        child_module::public_function()
        self::child_module::public_function()
      if we are in child_module.rs, we can use:
        super::sibling_module::StructName::new()

#Use keyword: bring a path into a scope once and then call the items in that path as if they’re local items
  Use can be defined
    at the top of the file (outside of any block in a file)
    inside a block (it will then bring a path into the local block scope)
#Definition
  #with absolute path:
    use crate::parent_module::child_module;
    child_module::public_function()     //you can now call public_function like this
  #with relative path:
    use super::sibling_module::StructName;
  #with glob operator (to bring all public items defined in a path into scope):
    use std::collections::*;
  #with alias:
    use std::io::Result as IoResult;    //this will avoid name collision with the other Result
    use std::fmt::Result;
  #with nested paths:
    use std::{cmp::Ordering, io};       //same with: use std::cmp::Ordering; use std::io;
    use std::io::{self, Write};         //same with: use std::io; use std::io::Write;
#Use convention
  You can `use` directly to a function name. But it isn't idiomatic.
    Bringing the function’s parent module into scope with `use`
    forces us to specify the parent module when calling the function
    which makes it clear that the function isn’t locally defined
    while still minimizing repetition of the full path.
  On the other hand, when bringing in structs, enums, and other items with use,
    it’s idiomatic to specify the full path.
    There’s no strong reason behind this idiom: it’s just the convention that has emerged.
    The exception to this idiom is if we’re bringing two items with the same name into scope with use statements
#Re-exporting with pub use
  When we bring a name into scope with the use keyword,
    the name available in the new scope is private.
  To enable the code that calls our code to refer to that name
    as if it had been defined in that code’s scope,
    we can combine pub and use.
#Re-exporting example
  !child_module.rs
  pub use super::sibling_module::StructName;
  //make StructName accessible from both child_module.rs and any file that use child_module

#Rust standard library
  Because the standard library is shipped with the Rust language,
    we don’t need to change Cargo.toml to include std.
  But we do need to refer to it with `use` to bring items from there into our package’s scope
    use std::io;
#Rust prelude
  Rust inserts
    `extern crate std;` into the crate root of every crate
    `use std::prelude::v1::*;` into every module

#--------------------------------------------------------------------------------
#Attribute
  metadata applied to some module, crate, or item
  attribute application can be separated over multiple lines
#Applying attribute
  #crate level attribute      : #![attribute]
  #module and item level attribute: #[attribute]
  #with arguments:
    #[attribute = "value"]
    #[attribute(key = "value")]
    #[attribute(value, value)]
#Example
  //allow dead code
    #[allow(dead_code)]
    fn unused_function() {}
  //crate attributes
    #![crate_type = "lib"]      //with this we no longer need to pass the --crate-type=lib flag to rustc
    #![crate_name = "library_name"]

#--------------------------------------------------------------------------------
#Error Handling
  when failure is expected, return a Result instead of calling panic!
  use panic:
    in examples, prototype code, and tests
    when you know that failure is impossible:
      let home: std::net::IpAddr = "127.0.0.1".parse().unwrap();
    when it’s possible that your code could end up in a bad state
      a bad state is when some assumption, guarantee, contract, or invariant has been broken,
        such as when invalid values, contradictory values, or missing values are passed to your code.
      a bad state is not something that’s expected to happen occasionally.
      your code after this point needs to rely on not being in this bad state.
      attempting to operate on invalid data can expose your code to vulnerabilities.
  functions often have contracts: the inputs must meet particular requirements.
    Panicking when the contract is violated makes sense
      because a contract violation always indicates a caller-side bug
      and it’s not a kind of error you want the calling code to have to explicitly handle.
    In fact, there’s no reasonable way for calling code to recover;
      the calling programmers need to fix the code.
    Contracts for a function, especially when a violation will cause a panic,
      should be explained in the API documentation for the function.

#Unrecoverable Errors with panic!
    fn main() {
      panic!("crash and burn");
    }
  When the panic! macro executes, your program will print a failure message, unwind and clean up the stack, and then quit
  This walking back and cleanup is a lot of work. The alternative is to immediately abort.
    This ends the program without cleaning up.
    Memory that the program was using will then
    need to be cleaned up by the operating system.
    If in your project you need to make the resulting binary as small as possible,
    you can switch from unwinding to aborting upon a panic by adding this in your Cargo.toml:
      [profile.release]   #you can change release to other mode
      panic = 'abort'
  the filename and line number reported by the error message will be
    where the panic! macro is called, not the line of our code that eventually led to the panic! call
  To get backtrace, the RUST_BACKTRACE env variable must be switched on:
    RUST_BACKTRACE=1 cargo run
  In order to get backtraces with this information, debug symbols must be enabled.
    Debug symbols are enabled by default when using cargo build or cargo run without the --release flag

#Recoverable Errors with Result
  #match manually:
    use std::fs::File;
    use std::io::ErrorKind;
    fn main() {
      let f = File::open("hello.txt");
      let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
          ErrorKind::NotFound => match File::create("hello.txt") {
            Ok(fc) => fc,
            Err(e) => panic!("Problem creating the file: {:?}", e),
          },
          other_error => {
            panic!("Problem opening the file: {:?}", other_error)
          }
        },
      };
    }
  #with unwrap_or_else:
    fn main() {
      let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
          File::create("hello.txt").unwrap_or_else(|error| {
            panic!("Problem creating the file: {:?}", error);
          })
        } else {
          panic!("Problem opening the file: {:?}", error);
        }
      });
    }
  #unwrap and expect methods
      fn main() {
        let f = File::open("hello.txt").unwrap();
        let f = File::open("hello.txt").expect("Failed to open hello.txt");
      }
    unwrap will call the panic! macro for us if Result is Err
    expect also raise panic but you can supply an error message
#Propagating error: return the error to the calling code so that it can decide what to do
  #match manually:
    use std::fs::File; use std::io; use std::io::Read;
    fn read_username_from_file() -> Result<String, io::Error> {
      let f = File::open("hello.txt");

      let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
      };

      let mut s = String::new();

      match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
      }
    }
  #using the ? operator for propagating error
    #Example:
      fn read_username_from_file() -> Result<String, io::Error> {
        let mut s = String::new();
        File::open("hello.txt")?.read_to_string(&mut s)?;
        Ok(s)
      }
    #Explanation:
      If the value of the Result is an Ok,
        the value inside the Ok will get returned from this expression, and the program will continue.
      If the value is an Err,
        the Err will be returned from the whole function
        as if we had used the return keyword
        so the error value gets propagated to the calling code.
      error values that have the ? operator called on them
        is automatically converted into the error type defined in the return type of the current function
        using the from function defined in the From trait
        if each error type implements the from function to define how to convert itself to the returned error type.
      use the ? operator in a function that returns Result or Option or another type that implements std::ops::Try.
    #using ? in main function
      use std::error::Error; use std::fs::File;
      fn main() -> Result<(), Box<dyn Error>> {   //main can return Result or Option
        let f = File::open("hello.txt")?;
        Ok(())
      }

#--------------------------------------------------------------------------------
#Generic
  Generic type parameter names convention in Rust:
    are short, often just a letter, usually T
    is CamelCase
  We pay no runtime cost for using generics in Rust
    because Rust perform monomorphization of the code that is using generics at compile time.
  Monomorphization: the process of turning generic code into specific code
    by code generation (filling in the concrete types that are used when compiled).
    This expands the generic definition of Option<T> into Option_i32 and Option_f64,
    thereby replacing the generic definition with the specific ones
#Usage
  You don't need to annotate generic type parameter when it can be inferred:
    let option_bool = Option(true)  //no need for `let option_bool: Option<bool> = Option(true)`
  Function or method sometimes need to have their type parameter explicitly specified
    we can do this using the turbofish syntax:
    function_name::<f32, i32>(x, y)
    item.method_name::<f32, i32>(x, y)
#Function
  fn function_name<T,U>(parameter_name: T, parameter_name: U) -> U { expression }
#Struct
  struct Point<T,U> { x: T, y: U }
#Enum
  enum Option<T> { Some(T), None }
  enum Result<T, E> {
    Ok(T),
    Err(E),
  }
#Method
  #for: struct Point<T, U> {x: T, y: U}
  #concrete method with generic struct
    impl Point<f32, i32> { fn method_name() {} }
  #generic method with generic struct
    impl<T, U> Point<T, U> {
      fn method_name(&self) -> &T { &self.x }
    }
  #generic method with generic struct and generic method parameter and return type
    impl<T, U> Point<T, U> {
      fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point { x: self.x, y: other.y }
      }
    }
#Trait
  struct Empty; struct Null;      //non-copyable types.
  trait DoubleDrop<T> {         //a trait generic over T
    fn double_drop(self, _: T);
  }
  impl<T, U> DoubleDrop<T> for U {  //implement DoubleDrop for any generic parameter T and caller U
    fn double_drop(self, _: T) {}   //takes ownership of both passed arguments, deallocating both.
  }
  fn main() {
    let empty = Empty;
    let null  = Null;
    empty.double_drop(null);    //deallocate empty and null.
  }


#--------------------------------------------------------------------------------
#Traits
  are similar to interfaces in other languages, but are more powerful
  Trait definitions group method signatures together to define methods necessary to accomplish some purpose.
    Types share the same behavior if we can call the same methods on them.
  we can implement a trait on a type only if either the trait or the type is local to our crate
    we can’t implement external traits on external types
    This restriction is part of a property of programs called coherence,
    and more specifically the orphan rule (the parent type is not present).
    Without the rule, two crates could implement the same trait for the same type,
    and Rust wouldn’t know which implementation to use.
#Defining
  pub trait Summary {
    fn summarize(&self) -> String;
    fn function_with_default_implementation(&self) -> String {
      //to add default implementation, just add a function body
      //default implementation can be overriden when implementing trait on a type

      self.summarize
      //default implementations can call other methods in the same trait,
      //  even if those other methods don’t have a default implementation.
      //it isn’t possible to call the default implementation
      //  from an overriding implementation of that same method.
    }
  }
#Implement trait on a type
  pub struct Tweet { pub username: String, pub content: String, pub retweet: bool }
  impl Summary for Tweet {
    fn summarize(&self) -> String { format!("{}: {}", self.username, self.content) }
  }
#Implement trait with default implementation on a type
  impl TraitName for StructName {}  //we can use empty impl block if all trait's methods have default implementation
#Using trait as parameter
  #with impl trait syntax sugar:
    pub fn function_name(parameter: impl TraitName) { statements; }
  #with trait bound syntax:
    pub fn function_name<T: TraitName>(item: T) { statements; }
  #with multiple trait parameters:
    pub fn function_name(parameter: impl TraitName + TraitName) { statements; }
    pub fn function_name<T: TraitName + TraitName>(item: T) { statements; }
  #with where clause:
    //messy without where clause
      fn function_name<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}
    //cleaner with where clause
      fn some_function<T, U>(t: T, u: U) -> i32
        where T: Display + Clone, U: Clone + Debug {}
    //very hard without where clause
    //where clause can apply bounds to arbitrary types like Option, rather than just to type parameters.
      trait PrintInOption { fn print_in_option(self); }
      impl<T> PrintInOption for T where Option<T>: Debug {
        fn print_in_option(self) { println!("{:?}", Some(self)); }
      }
#Using trait as return type
    fn function_name() -> impl TraitName {}
  #note:
    you can only return a single type when using trait as return type
      e.g. code that returns either a NewsArticle or a Tweet
      with the return type specified as impl Summary trait wouldn’t work
      due to restrictions around how the impl Trait syntax is implemented in the compiler.
    we can use Trait Objects to return values of different types
#Using trait bounds to conditionally implement generic methods
  struct Pair<T> {x: T, y: T}
  impl<T> Pair<T> {
    //this method will be implemented on Pair with all type
    fn new(x: T, y: T) -> Self { Self { x, y } }
  }
  impl<T: Display + PartialOrd> Pair<T> {
    //this method will be implemented only if Pair inner type T implements the PartialOrd and Display trait
    fn cmp_display(&self) {
      println!("The largest member is {}", if self.x >= self.y { &self.x } else { &self.y });
    }
  }
#Blanket implementations (implement a trait on any type that satisfies the trait bounds)
  impl<T: Display> ToString for T {
    //implement the ToString trait for any type T that satisfies the trait bound T:Display
  }
#Using empty trait bounds to group types
  the function below will only take value of type StructName1 or StructName2
    trait TraitName {}
    impl TraitName for StructName1 {}
    impl TraitName for StructName2 {}
    fn function_name(parameter: impl TraitName) { statements; }
  Eq and Ord are examples of empty bounds from the std library.

#New Type Idiom
  newtype idiom gives compile time guarantees that the right type of value is supplied to a program.
  you can use this idiom for example to supply unit of measures
#Example
  struct Years(i64); struct Days(i64);
  impl Years { pub fn to_days(&self) -> Days { Days(self.0 * 365)} }
  impl Days { pub fn to_years(&self) -> Years { Years(self.0 / 365) } }
  fn old_enough(age: &Years) -> bool {  //this will guarantee that the value supplied is of type Years
    age.0 >= 18             //use tuple syntax to obtain the newtype's value as the base type
  }
  fn main() {
    let age = Years(5); let age_days = age.to_days();
    println!("{}", old_enough(&age));           //OK
    println!("{}", old_enough(&age_days.to_years()));   //OK
    println!("{}", old_enough(&age_days));        //compile error because the type supplied is Days
  }

#--------------------------------------------------------------------------------
#Associated Types
  struct Container(i32, i32);
  trait Contains {  //A trait which checks if 2 items are stored inside of container.
    type A; type B; //Define associated types
    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;
    fn first(&self) -> i32;
    fn last(&self) -> i32;
  }
  impl Contains for Container {
    type A = i32; type B = i32;
    // `&Self::A` and `&Self::B` are also valid here.
    fn contains(&self, x: &i32, y: &i32) -> bool {
      (&self.0 == x) && (&self.1 == y)
    }
    fn first(&self) -> i32 { self.0 }
    fn last(&self) -> i32 { self.1 }
  }
  fn difference<C: Contains>(container: &C) -> i32 {
    container.last() - container.first()

    //without associated types, we'll need to define this function in a more complicated way:
    //  fn difference<A, B, C>(container: &C) -> i32 where C: Contains<A, B> {
  }
  fn main() {
    let x = 3; let y = 10; let container = Container(x, y);
    println!("Does container contain {} and {}: {}", &x, &y, container.contains(&x, &y));
    println!("The difference is: {}", difference(&container));
  }

#--------------------------------------------------------------------------------
#Lifetimes
  every reference in Rust has a lifetime (the scope for which that reference is valid).
  names of lifetime parameters
    start with an apostrophe ('), usually all lowercase and very short.
    most people use the name 'a, 'b, etc.
  similar to generic
    rather than ensuring that a type has the behavior we want,
      lifetimes ensure that references are valid as long as we need them to be
  similar to type
    lifetimes are often implicit and inferred
    we must annotate lifetimes when the lifetimes of references could be related in a few different ways
      (we must annotate types when multiple types are possible)
  Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid
  disallow operations that would create dangling pointers or otherwise violate memory safety.

#Dangling reference
  is an attempt to use a reference whose value has gone out of scope (borrowing dropped value)
    which causes the program to reference data other than the data it’s intended to reference
  When returning a reference from a function,
    the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.
    If not, it refers to a value created within this function that will go out of scope at the end of the function,
    which would be a dangling reference.
    the best fix would be to return an owned data type rather than a reference
    so the calling function is then responsible for cleaning up the value
  #illustration
    {
      let r;                // ──────┬─'a //note that 'a and 'b lifetimes
      {                     //       │    //  starts at variable declaration
        let x = 5;          // ─┬─'b │    //  and not block opening
        r = &x;             //  │    │
      }                     // ─┘    │    //while value goes out of scope at the end of scope (when it's dropped)
      println!("r: {}", r); // ──────┘    //  reference goes out of scope the last time it is used
    }
  #note:
    At compile time, Rust
      compares the size of the two lifetimes
      sees that r has a lifetime of 'a but that it refers to memory with a lifetime of 'b.
      rejects the program because 'b is shorter than 'a
        (r outlives/lives longer than x)
        (x has smaller lifetime than r)
        because the subject of the reference doesn’t live as long as the reference
#Valid reference
  #illustration
    {
      let x = 5;            // ──────┬─'b
      let r = &x;           // ─┬─'a │
      println!("r: {}", r); // ─┘    │
    }                       // ──────┘
  #note: valid reference because the data has a longer lifetime than the reference

#Lifetime Annotation Syntax
  &i32    // a reference
  &'a i32   // a reference with an explicit lifetime
  &'a mut i32 // a mutable reference with an explicit lifetime
#Lifetime Annotations in Function Signatures
  #example of generic lifetimes parameters and return values
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {   //'a in this context is called the generic lifetime parameter
      if x.len() > y.len() { x } else { y }         //  and it will be substituted with a concrete lifetime
    }                             //  every time the function is called
    fn main() {
      let s1 = String::from("long string is long");
      {
        let s2 = String::from("xyz");           //the concrete lifetime of s2
        let result = longest(s1.as_str(), s.as_str());  //  will be passed to this function
        println!("The longest string is {}", result);   //  because it overlaps and is smaller with s1 lifetime
      }
    }
  #note:
    The function takes two parameters which live at least as long as lifetime 'a.
    The returned value from the function will live at least as long as lifetime 'a.
      In practice, this means that the lifetime of the reference returned by the longest function
      is the same as the smaller of the lifetimes of the references passed in.
    The lifetimes might be different each time the function is called
      the function doesn’t know exactly how long x and y will live,
      only that some scope can be substituted for 'a that will satisfy this signature.
  #dangling reference example
    fn main() {
      let string1 = String::from("long string is long"); let result;
      {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());   //if no concrete lifetime can be supplied,
      }                               //  then Rust will raise compile error
      println!("The longest string is {}", result);
    }
#Lifetime Annotations in Struct Definitions
    So far, we’ve only defined structs to hold owned types.
    It’s possible for structs to hold references,
      but we would need to add a lifetime annotation
      on every reference in the struct’s definition.
  #example: struct ImportantExcerpt<'a> { part: &'a str }
  #note: this annotation means an instance of ImportantExcerpt can’t outlive the reference it holds in its `part` field
#Lifetime Annotations in Method Definitions
  #example:
    impl<'a> ImportantExcerpt<'a> {
      fn level(&self) -> i32 { 3 }
    }
  #note:
    Lifetime names for struct fields always need to be declared
      after the impl keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type.
    Lifetime annotations aren’t always necessary in method signatures
      because of the lifetime elision rules.

#The static lifetime ('static)
  means that this reference can live for the entire duration of the program
  All string literals have static lifetime:
    let s: &'static str = "I have a static lifetime.";
  When you see error messages suggesting that you use the 'static lifetime
    consider whether you want it to live that long, even if it could.
    Most of the time, the problem results from
      attempting to create a dangling reference
      or a mismatch of the available lifetimes.

#Lifetime Elision Rules
  are patterns programmed into Rust’s analysis of references.
  If Rust deterministically applies the rules
    but there are still references for which it can’t figure out lifetimes,
    the compiler will give you an error that you can resolve by adding the lifetime annotations
    that specify how the references relate to each other.
  Lifetimes on
    function or method parameters are called input lifetimes
    return values are called output lifetimes
#The rules
  These rules apply to fn definitions as well as impl blocks
  - each parameter that is a reference gets its own lifetime parameter
    fn foo<'a, 'b>(x: &'a i32, y: &'b i32)  //a function with 2 parameters gets 2 separate lifetime parameters
  - if there's one input lifetime parameter, that lifetime is assigned to all output lifetime parameters
    fn foo<'a>(x: &'a i32) -> &'a i32.
  - if there are multiple input lifetime parameters,
    but one of them is &self or &mut self because this is a method,
    the lifetime of self is assigned to all output lifetime parameters

#--------------------------------------------------------------------------------
#Phantom
  PhantomData vs phantom types
    A phantom type parameter is simply a type parameter which is never used
    this often causes the compiler to complain, and the solution is
    to add a dummy use by way of std::marker::PhantomData
  A phantom type parameter
    doesn't show up at runtime
    is checked statically at compile time
  Data types can use extra generic type parameters to act as markers or to perform type checking at compile time.
  These extra parameters hold no storage values, and have no runtime behavior.
  see The Rustonomicon for more explanation

#--------------------------------------------------------------------------------
#Testing
  A test in Rust is a function that’s annotated with the test attribute:
    #[test]
    fn function_name() {}
  When you run your tests with the cargo test command,
    Rust builds a test runner binary and then run the functions annotated with the test attribute
    and reports on whether each test function passes or fails.
  When we make a new library project with Cargo (cargo new --lib package_name)
    a test module with a test function in it is automatically generated for us.
  Tests fail when something in the test function panics
  Tests module is a regular module that follows the usual visibility rules
    Because the tests module is an inner module,
    we need to bring the code under test in the outer module
    into the scope of the inner module with `use super::*;`
  For assertions like assert_eq, the values being compared must implement the PartialEq and Debug traits.
    Because both traits are derivable traits,
    this is usually as straightforward as adding
    the #[derive(PartialEq, Debug)] annotation to your struct or enum definition

#Assertions
  assert!(condition)
  assert_eq!(left, right)
  assert_ne!(left, right) //not equal
#Assert with failure message: additional arguments are passed along to the format! macro
  assert!(condition, "add custom failure message here {}", variable_name)
  assert_eq!(left, right, "add custom failure message here {}", variable_name)

#should_panic macro
  basic:
    #[test] #[should_panic]
    fn function_name() {}
  note:
    To make should_panic tests more precise,
    we can add an optional expected parameter to the should_panic attribute.
    The test harness will make sure that the failure message contains the provided text.
  with expected parameter:
    #[test] #[should_panic(expected = "the panic must include this string as substring")]
    fn function_name() {}

#Example unit test
  pub struct Guess { value: i32 }
  impl Guess {
    pub fn new(value: i32) -> Guess {
      if value < 1 || value > 100 { panic!("Guess value must be between 1 and 100, got {}.", value); }
      Guess { value }
    }
  }

  #[cfg(test)]
  mod tests {
    use super::*;

    #[test] #[should_panic]
    fn greater_than_100() {
      Guess::new(200);
    }
  }

#Return Result<T, E> in Tests
  This enables you to use the question mark operator in the body of tests,
    which can be a convenient way to write tests that should fail
    if any operation within them returns an Err variant.
  You can’t use the #[should_panic] annotation on tests that use Result<T, E>
    instead, you should return an Err value directly when the test should fail
#Example
  #[cfg(test)]
  mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
      if 2 + 2 == 4 { Ok(()) }
      else { Err(String::from("two plus two does not equal four")) }
    }
  }

#Ignoring Some Tests
  run only the ignored tests: cargo test -- --ignored
  run all tests (ignored or not): cargo test -- --include-ignored
#Example
  #[test]
  #[ignore]
  fn expensive_test(){}  // code that takes an hour to run

#Test Organization
  unit tests go in the same files as the code
    put unit tests in the src directory in each file with the code that they’re testing.
      create a cfg(test) module named tests in each file to contain the test functions.
    Rust’s privacy rules do allow you to test private functions.
      tests are just Rust code and the tests module is just another module inside the code under test,
      you can bring private function into a test’s scope using: use super::*;
  integration tests go in a tests directory at the top level of our project directory, next to src
    make as many test files as we want to in this directory.
      Cargo will compile each of the files as an individual crate.
      this simulates the way end users will be using your crate.
    they don’t need the #[cfg(test)] annotation
      because Cargo already compiles files in this directory only when we run cargo test.
    run a particular integration test function
      by specifying the test function’s name as an argument to cargo test
    To run all the tests in a particular integration test file,
      use the --test argument of cargo test followed by the name of the file:
        cargo test --test integration_test_happy_path
#Submodules in Integration Tests
  helper functions that would be useful in multiple integration test files go inside tests/common/file.rs
  after we’ve created tests/common/mod.rs, we can use it from any of the integration test files as a module
  files in subdirectories of the tests directory don’t get compiled as separate crates
    or have sections in the test output.
  If our project is a binary crate that only contains a src/main.rs file with no src/lib.rs file,
    we can’t bring functions defined in the src/main.rs file into integration tests' scope with a use statement.
    library crates can expose functions other crates can use; binary crates are to be run on their own.

#--------------------------------------------------------------------------------
#Bookmarks

read and summarize:
  Cargo book -> ,rs.cargo.txt
  rustdoc book -> ,rs.rustdoc.txt
  rustc book -> ,rs.rustc.txt
Optional:
  https://www.rust-lang.org/learn
  the Rustonomicon, Reference, WebAssembly, Command Line book

Rust by Example:
1.2 Formatted Print
9.2.2 As input parameters
12.4 Build Scripts (should be in ,rs.cargo.txt)
15 Scoping Rules
16 Traits
17 macro_rules!
18 Error Handling
  18.4.2 - 18.4.5 (to be added) (wait until I understand trait object dynamic dispatch) (see Defining an error type??? above)
19 Std library types
20 Std misc
21 Testing
22 Unsafe operation
23 Compatibility
24 Meta

The Rust Programming Language:
12.3. Refactoring to Improve Modularity and Error Handling

Rust Functions
x  #using named tuple: func function_name() -> (name: Type, name: Type, ...) { return (value, value, ...) }
x  #with optional return value
x  func function_name() -> Return_Type? { return value }
x  func function_name() -> (Type, Type, ...)? { return (value, value, ...) }
x  #with default parameter: func function_name(parameter_name: Type, parameter_name: Type = value){ statements }
#Variadic function
x  func function_name(xs: Int...) -> () { print(xs) }; function_name(xs: 1,2,3);
x  func function_name(_ xs: Int...) -> () { print(xs) }; function_name(1,2,3);
#Higher-order function:
x  func function_name(callback: ((Type, Type) -> Type)) -> ((Type) -> Type){ statements }
#In-out parameters
x  is a way for a function to have an effect (i.e. changing a variable value) outside of the scope of its body
x  func function_name(parameter_name: inout Type, parameter_name: inout Type){ statements }
x  function_name(&parameter_name, &parameter_name)



fn print_TypeName_of<T>(_: T) {
  println!("{}", unsafe { std::intrinsics::TypeName::<T>() })
}

Create an integer in the heap: Box::new(3)