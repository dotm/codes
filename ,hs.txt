Haskell is statically typed (with automatic type inference)
Whitespace matters in Haskell

You can use tab completion in GHCi
  You can see all function using tab completion (in an empty command line, press tab, press y to display all possibilities)

  :{ GHCi multiline command :}
#Comment
  {- A multiline comment  -}
  -- a single line comment

#Loading function(module):
  !file_name.hs
  $ :l file_name
#Reload function:
  :r (or just repeat :l file_name)
#get information on a token
  :t
  :info
  :k    #get the kinds of a token

#Let keyword
Doing let a = 1 inside GHCi is equivalent of writing a = 1 in a script and then loading it.
let can NOT be used when using compiler

#Running Haskell program
  $ runhaskell helloworld.hs
#Compiling Haskell program
  $ ghc --make helloworld
#Running Haskell program from compiled file
  $ ./helloworld

#-------------------------------------------------------------------------------------
#Main keyword
  An I/O action will be performed when we give it a name of main and then run our program.
  By convention, we don't usually specify a type declaration for main.
  in a do block, the last action cannot be bound to a name
    the do block automatically extracts the value from the last action and binds it to its own result.
  use <- when you want to bind results of I/O actions to names
    and use let bindings to bind pure expressions to names

#Using main keyword
  #for one I/O action
    main = putStrLn "hello, world"
  #for multiple I/O action
    main = do
        putStrLn "Hello, what's your name?"
        name <- getLine
        putStrLn ("Hey, " ++ name ++ "!")
  #with let binding
    main = do
      putStrLn "What's your first name?"
      firstName <- getLine
      putStrLn "What's your last name?"
      lastName <- getLine
      let bigFirstName = map toUpper firstName
          bigLastName = map toUpper lastName
      putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
  #recursive main
    main = do
    line <- getLine
    if null line        #if line is empty
        then return ()  #then do nothing
        else do
            putStrLn $ reverseWords line
            main
#-------------------------------------------------------------------------------------
#Exceptions
  Despite having expressive types that support failed computations (Maybe, Either),
    Haskell still has support for exceptions
  Exceptions make more sense in I/O contexts
    A lot of things can go wrong when dealing with the outside world because it is so unreliable.
    I/O code (i.e. impure code) can throw and handle exceptions.
  Pure code can throw exceptions
    but exceptions can only be caught in the I/O part of our code
      (when we're inside a do block that goes into main)
    And that's bad, because we want to keep the I/O part as small as possible.
      Even when glueing together I/O actions that might fail,
        I prefer to have their type be something like IO (Either a b)
        than to throw and catch an exception
    But, if we don't catch the exception, our program crashes.
    The solution? Don't mix exceptions and pure code. Minimize exception occurrence.
      use types like Either and Maybe to represent results that may have failed.
      use functions that handle edge cases that may throw exceptions
      create function that handle exceptions manually using pattern matching, if expression, etc.

#Catching exception
  System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
    It takes two parameters.
    The first one is an I/O action. e.g. read a file.
    The second one is the exception handler.
  Using catch as an infix function makes it more readable
    toTry `catch` handler
  The handler takes a value of type IOError,
    which carries information regarding the type of the exception that was thrown.
  How IOError type is implemented depends on the implementation of the language itself,
    we can't inspect values of the type IOError by pattern matching against them
    We use predicate functions from System.IO.Error to inspect values of type IOError:
      isAlreadyExistsError
      isDoesNotExistError
      isAlreadyInUseError
      isFullError
      isEOFError
      isIllegalOperation
      isPermissionError
      isUserError
#isUserError
  isUserError evaluates to True when we use the function userError to make the exception,
    which is used for making exceptions from our code and equipping them with a string.
  e.g. ioError $ userError "remote computer unplugged!"
#ioError :: IOException -> IO a
  it takes an IOError and produces an I/O action that will throw it
#Example
    import System.IO.Error
    main = toTry `catch` handler
    handler :: IOError -> IO ()
    handler e
      | isDoesNotExistError e =
        case ioeGetFileName e of
          Just path -> putStrLn $ "Whoops! File does not exist at: " ++ path
          Nothing -> putStrLn "Whoops! File does not exist at unknown location!"
      | otherwise = ioError e
  We use guard syntax here, but we could have also used an if else.
  if the exception thrown is not handled by the other predicate, it will just be re-thrown by ioError
    if you don't re-throw the exception, your program will fail silently (this may be bad)

#-------------------------------------------------------------------------------------
#I/O
  I/O actions are values much like any other value in Haskell
  I/O action is something that, when performed, will carry out an action with a side-effect
    (that's usually either reading from the input or printing stuff to the screen)
    and will also contain some kind of return value inside it
  the 'IO ()' means an I/O action that has a result type of '()' (i.e. the empty tuple, also know as unit)
    the IO type represents I/O action
    since string output doesn't really have any kind of meaningful return value,
      a dummy value of () is used.
  the only way to get the tainted data inside string input I/O action is to use the <- construct
    and we can only take data out of an I/O action when we're inside another I/O action.
  This is how Haskell neatly separate the pure and impure parts of our code.
    I/O action is impure because its result value is not guaranteed to be the same when performed twice.
    the data inside of IO is sort of tainted with the IO type constructor and we can only get that data out in I/O code.
    And because I/O code is tainted too, any computation that depends on tainted I/O data will have a tainted result.
    we temporarily un-taint the data inside an I/O action when we bind it to a name.
      When we do name <- getLine, name is just a normal string
  The impure part of the code exists in the do block of main
    I/O actions will only be performed when they are given a name of main
    or when they're inside a bigger I/O action that we composed with a do block of main.
  I/O actions will also be performed when we type out an I/O action in GHCI and press return.
    GHCI uses 'print' on that value to display it on our terminal!
#Do keyword
  The do keyword wraps one or multiple line of I/O action into one I/O action
#Return keyword
  return keyword doesn't end execution
  return just does the opposite of <-
  return takes a value and wraps it in an I/O action box
  When dealing with I/O do blocks, we mostly use return either because
    we need to create an I/O action that doesn't do anything (i.e. 'return ()')
    or we don't want the I/O action that's made up from a do block
      to have the result value of its last action,
      but we want it to have a different result value,
      so we use return to make an I/O action
        that always has our desired result contained and we put it at the end.
#I/O module
  Control.Monad
  System.IO
  System.Directory
  System.Environment

#Binding I/O action result to a name
  variableName <- getLine
  _ <- putStrLn "Hello"     #the _ will be () which is useless
#User string input
  getLine :: IO String
  getChar :: IO Char
  getContents :: IO String        #get all lines until end of file character (CTRL+D)
#String output
  putStr :: String -> IO ()
  putStrLn :: String -> IO ()     #put string with new line at the end
  print :: Show a => a -> IO ()   #if a is String, it will have "" around it, unlike putStr or putStrLn
#interact function
    interact :: (String -> String) -> IO ()
  getContents, transform the string using the function supplied as argument, output the result

#File handler I/O functions
  hGetContents, hGetLine, hGetChar  #read from file inside file handler
  hPutStr, hPutStrLn                #write to file inside file handler
#Manual File I/O
    openFile :: FilePath -> IOMode -> IO Handle
    type FilePath = String
    data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
    hGetContents: is like getContents but for file handle
    hClose: takes a handle and returns an I/O action that closes the file
  import System.IO
  main = do
      handle <- openFile "a.txt" ReadMode
      contents <- hGetContents handle
      putStr contents
      hClose handle
#Using withFile
    withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
  import System.IO
  main = do
      withFile "girlfriend.txt" ReadMode (\handle -> do
          contents <- hGetContents handle
          putStr contents)
#Automatic File I/O
  #readFile :: FilePath -> IO String
    import System.IO
    main = do
        contents <- readFile "girlfriend.txt"
        putStr contents
  #writeFile :: FilePath -> String -> IO ()
  #appendFile :: FilePath -> String -> IO ()

#-------------------------------------------------------------------------------------
#System.Random
  The RandomGen typeclass is for types that can act as sources of randomness.
  The Random typeclass is for things that can take on random values.
    check ':info Random' to see what are the instances of Random

#Manual random generator
    random :: (RandomGen g, Random a) => g -> (a, g)
    mkStdGen :: Int -> StdGen
  random (mkStdGen 100)
  random (mkStdGen 100) :: (Bool, StdGen)
#Generate array of random
  randoms takes a generator and returns an infinite sequence of values based on that generator
    take 5 $ randoms (mkStdGen 11) :: [Float]

#Random with range
  randomR takes as its first parameter a pair of values that set the lower and upper bounds of random
    randomR (1,6) (mkStdGen 359353)
#Generate array of random within a range
  take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]

#System random generator
    import System.Random
    main = do
      gen <- getStdGen
      putStr $ take 20 (randomRs ('a','z') gen)
  System.Random offers the getStdGen I/O action, which has a type of IO StdGen.
  When your program starts,
    it asks the system for a good random number generator
    and stores that in a so called global generator.
  getStdGen fetches you that global random generator when you bind it to something.
#Multiple getStdGen
    import System.Random
    main = do
      gen <- getStdGen
      putStrLn $ take 20 (randomRs ('a','z') gen)
      gen' <- newStdGen
      putStr $ take 20 (randomRs ('a','z') gen')
    main = do
      gen <- getStdGen
      putStrLn $ take 20 (randomRs ('a','z') gen)
      newStdGen
      gen' <- getStdGen
      putStr $ take 20 (randomRs ('a','z') gen')
  just performing getStdGen twice will ask the system for the same global generator twice.
  use the newStdGen action,
    which splits our current random generator into two generators.
    It updates the global random generator with one of them
    and encapsulates the other as its result.

#-------------------------------------------------------------------------------------
#Operators

#Arithmetic operators: + - * / div mod ^
#Comparators: == /= <= >= < >
#Boolean operators: && || not
  #Boolean data type: True False

#Fixity declarations
    infixl 7 *        #is for multiplication
    infixr 5 :        #is for list cons
  When we define functions as operators, we can give them a fixity.
  A fixity states how tightly the operator binds and whether it's left-associative or right-associative.

#-------------------------------------------------------------------------------------
#Functions
  function can't begin with uppercase letter
  single quotes (') is a valid character (you can use it in function_name)
  a function has no side-effects
    function can only calculate something and return it as a result
  every expression and function must return something
#Assertion of Equivalence (Definition/Name/Constant)
    myName = "Yoshua"
  a definition (or a name) is a function that
    doesn't take any parameters and always return the same value

#Definition
    name = value
  #define string using double quotes: myName = "Yoshua"
  #define character using single quotes: a = 'a'

#Function definition (in Haskell source file)
  function_name parameter1 parameter2 = statements
    e.g. add x y = x+y
#Function definition (in GHCi interpreter)
  let function_name parameter1 parameter2 = statements
#Function call/application
  function_name parameter1 parameter2
  (function_name parameter1 parameter2) #you can put () around function call to make it clearer
#Infix function
  functions with 2 parameters can be called and defined as infix function using backticks to avoid confusion between parameters
    div a b = function_body
      := a `div` b = function_body
    (div 92 10) := (92 `div` 10)

#-------------------------------------------------------------------------------------
#Conditional

#If expression
  the else part is mandatory,
  #Multiple line
    doubleSmallNumber x =
      if x > 100
      then x
      else x*2
  #Single line
    doubleSmallNumber x = if x > 100 then x else x*2
    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  #a different function with + 1

#-------------------------------------------------------------------------------------
#Lists
  are a zero indexed, homogenous, variable-length data structure
  [1,2,3] is syntactic sugar for 1:2:3:[]
    [] is an empty list
  multi-dimensional list := nested list
  jagged multi-dimensional list is allowed
#Strings
  strings are lists, we can use list functions on them
  "hello" is just syntactic sugar for ['h','e','l','l','o']
#Ranges
  floating point range are not completely precise by definition (e.g. instead of 1, you may get 0.999)
  you can only specify arithmetic sequences (sequences with constant difference between terms) with range

#List (and String)
  #Definition: a = [1,2,3]
  #Appending lists
    [1] ++ [2,3]            ->  [1,2,3]
    ['w','o'] ++ ['o','t']  ->  "woot"
  #Prepending lists
    'A':" SMALL CAT"  ->    "A SMALL CAT"
    5:[1,2]        ->    [5,1,2]
  #String interpolation
    "length: " ++ show 3 ++ " elements"   -> "length: 3 elements"
  #Access element by index
    "Yoshua" !! 1      ->  'o'
    [[1,2],[3]]!!0!!1  ->  2    #accessing multi-dimensional list
  #Comparing lists
      [3,2,1] > [2,100,1010]  ->  True
    lists can be compared in lexicographical order if they elements is comparable

#Basic list (and String) functions:
  length    [5,4,3,2,1]     ->  5
  null      []              ->  True      #check if list is empty
  head      [5,4,3,2,1]     ->  5
  tail      [5,4,3,2,1]     ->  [4,3,2,1]
  last      [5,4,3,2,1]     ->  1
  init      [5,4,3,2,1]     ->  [5,4,3,2]
  reverse   [3,2,1]         ->  [1,2,3]
  take      3 [5,4,3,2,1]   ->  [5,4,3]
    #if you take more elements than there are in the list, you'll just get original list
    #if you take 0 elements, you'll get an empty list.
  drop      3 [8,4,2,1,5,6] ->  [1,5,6]
    #works just like take
  minimum   [8,4,2,1,5,6]   ->  1
  maximum   [1,9,2,3,4]     ->  9
  sum       [5,2,1]         ->  8
  product   [6,2,1,2]       ->  24
  4 `elem`  [3,4,5,6]       ->  True    #check if a thing is an element of a list
#zip function
  takes 2 lists (can be of different type), zips them together into a list of pairs:
    zip [1 .. 5] ["one", "two", "three", "four", "five"]  ->  [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
  when the length doesn't match:
    zip [1..] ["a", "b", "c", "d"]      ->  [(1,"a"),(2,"b"),(3,"c"),(4,"d")]
#zipWith function
    zipWith (+) [4,2,5,6] [2,6,2,3]    ->     [6,8,7,9]
  takes a function and two lists as parameters
    and joins the two lists by applying the function between corresponding elements
#Operation on nested list
  zipWith (zipWith (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]   ->    [[3,4,6],[9,20,30],[10,12,12]]
  map (map (^2)) [[1,2],[3,4,5,6],[7,8]]    ->    [[1,4],[9,16,25,36],[49,64]]
#takeWhile function
    takeWhile (<3) [0,1,2,3,4]    ->    [0,1,2]
  takes a predicate and a list
    and goes from the beginning of the list
    and returns its elements while the predicate holds true.
      Once an element is found for which the predicate doesn't hold, it stops.
  takeWhile works well with infinite lists

#Ranges
    [0..3]      -> [0,1,2,3]
    ['a'..'z']  -> "abcdefghijklmnopqrstuvwxyz"
    ['K'..'Z']  -> "KLMNOPQRSTUVWXYZ"
  #with step other than +1, you must specify the second element
    [5,4..1]    -> [5,4,3,2,1]  #negative (-1) step
    [2,4..10]   -> [2,4,6,8,10] #with +2 step
    ['a','j'..'z'] -> "ajs"

#Infinite list
  #with range
      take 24 [13,26..]  #get the first 24 multiples of 13
    Haskell won't evaluate the infinite list immediately (lazy evaluation).
  #with cycle
      take 10 (cycle [1,2,3])  ->  [1,2,3,1,2,3,1,2,3,1]
      take 12 (cycle "LOL ")   ->  "LOL LOL LOL "
  #with repeat
    a list cycle with only one element.
      take 10 (repeat 5)  ->  [5,5,5,5,5,5,5,5,5,5]

#Difference List
  difference list is similar to a list,
    only instead of being a normal list,
    it's a function that takes a list and prepends another list to it.
  difference lists support efficient appending (++)

#Bytestring
  processing files as strings has one drawback: it tends to be slow
    since list is lazy, you can think of lists as promises (thunks)
      that the next element will be delivered once it really has to
      and along with it, the promise of the element after it.
    processing a simple list of numbers as a series of promises might not be the most efficient way
  Bytestrings come in two flavors: strict and lazy ones.
    Data.ByteString
    Data.ByteString.Lazy
  Strict bytestrings remove laziness completely.
    There are no promises involved
    a strict bytestring represents a series of bytes in an array.
    If you evaluate the first byte of a strict bytestring, you have to evaluate it whole.
    You can't have things like infinite strict bytestrings, since you don't have infinite memory.
  Lazy bytestrings are stored in chunks with a size of 64K.
    Lazy bytestrings are kind of like lists of strict bytestrings with a size of 64K.
  Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try

#-------------------------------------------------------------------------------------
#List comprehension
    in math, set comprehensions are normally used for building more specific sets out of general sets.
    in Haskell, list comprehensions are used for building more specific lists out of general lists.
#Nested list comprehensions
  nested list comprehensions are possible if you're operating on lists that contain lists.
  if you're not in GHCi, it's better to split longer list comprehensions across multiple lines.

#List comprehension
  #with input_set only
    [constant | input_set ]
    ['a' | x <- [1..3]] -> "aaa"
  #the _ placeholder
    instead of making a variable name that we'll never use (like x in the example above), we can just write _ as the variable
    ['a' | _ <- [1..3]] -> "aaa"
    [1 | _ <- [1..3]]   -> [1,1,1]
    length xs = sum [1 | _ <- xs]
  #with variable
    [variable | input_set ]
    [x | x <- ['a'..'e']] -> "abcde"
  #basic with output_function
    [output_function | input_set ]
    [x*2 | x <- [6..10]]  -> [12,14,16,18,20]
      x (variable), x*2 (output function), x <- [1..10] (input set)
  #filtering using predicate/condition
    [output_function | input_set, predicate]
    [output_function | input_set, predicate, predicate]
    [x*2 | x <- [1..10], x*2 >= 12]  -> [12,14,16,18,20]
  #multiple input
    [output_function | input_set, input_set]
    [output_function | input_set, input_set, predicate]
    [x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] ->  [55,80,100,110]
    [(x,y) | x <- [2,5,10], y <- [8,10,11]]         ->  [(2,8),(2,10),(2,11),(5,8),(5,10),(5,11),(10,8),(10,10),(10,11)]
  #conditional output_function
    [ if x < 10 then "BOOM!" else "BANG!" | x <- [7..13], odd x]  ->  ["BOOM!","BOOM!","BANG!","BANG!"]
  #with `elem` (is element of) in predicate
    [variable | input_set, variable `elem` a_list]    #include in the output only if it's an element of a_list
    removeNonUppercase string = [ c | c <- string, c `elem` ['A'..'Z']]
  #with pattern matching
    [output_function | pattern matching input_set ]
    [a+b | (a,b) <- [(1,3), (4,3), (2,4)]] -> [4,7,6]
  #with let binding
    [output_function | input_set, let binding, predicate]
    [bmi | (w, h) <- [(1,3), (4,3), (2,4)], let bmi = w / h ^ 2, bmi >= 25.0]
#Nested list comprehensions
  #basic
    [[output_function | variable <- inner_list_variable ] | inner_list_variable <- outer_list]
  #with predicate to filter the inner_list
    [[output_function | variable <- inner_list_variable, predicate ] | inner_list_variable <- outer_list]
  #with predicate to filter the outer_list
    [[output_function | variable <- inner_list_variable ] | inner_list_variable <- outer_list, predicate]

#-------------------------------------------------------------------------------------
#Tuple
    tuple_name = (element, element, ...)
  is a fixed-length and heterogeneous data structure
  tuples can be compared with each other if their components is comparable
  Use tuples instead of list when
    you know in advance how many components some piece of data should have
    you need heterogeneous data structure
  pair: tuple of size 2
  triple: tuple of size 3
#List of tuples
  must have the same type configuration (the tuple must be of the same size and each elements must be of the same type)
    let x=[(1,"la"),(2,3)]        ->    ERROR!!!
    let x=[(1,2),(8,11,5),(4,5)]  ->    ERROR!!!
  the tuples in a list of tuples can contain lists with different length but of the same type
    let x=[([1,2],["a","b"]),([3],["c"])]

#first and second function
    fst (8,11)  ->  8
    snd (8,11)  ->  11
  this will only work on pairs

#-------------------------------------------------------------------------------------
#Data Types
  #Int vs Integer: Int is bounded (have min and max value) but more efficient. Integer is not bounded.
  #Float vs Double: Double have more floating point precision than Float
  #Bool: True, False
  #Char (character) denoted by single quotes ''.
    A list of characters is a string: [Char] := String
  #Tuples
    #Zipper: a pair that contains a focused part of a data structure and its surroundings
      zipper makes it possible to move to a node without starting every traversal from the root of the data structure
  #Data modules
    see Learn You a Haskell book chapter 7
    Data.List (for List and String)
    Data.Char (for Char and String)
    Data.Map (for Map, which is a list of key-value pair tuple)
    Data.Set (for Set, which is an ordered list with unique element)
    Data.Maybe
      data Maybe a = Nothing | Just a
    Data.Either
      data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
        sometimes, Maybe a isn't good enough
          because Nothing doesn't really convey much information other than that something has failed.
        when we're interested in how some function failed or why,
          we usually use the result type of Either a b,
            where 'a' is some sort of type that can tell us something about the possible failure
            and 'b' is the type of a successful computation.
          Hence, errors use the Left value constructor while results use Right.

#Type reflection from GHCi
  :t expression  ->  expression :: data type
    :t True
    :t (==)
  a::b means "a has/have type of b"

#Giving function an explicit type declaration/signature/annotation
    removeNonUppercase :: [Char] -> [Char]
    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
#Declaring type signature in GHCi using let and semicolon:
    let add :: Int -> Int -> Int; add x y = x + y
#Multiple parameter function type signature
    addThree :: Integer -> Integer -> Integer -> Integer
    addThree x y z = x + y + z
  The return type is the last item in the declaration and the parameters are the first three.
  Haskell use -> and not comma for multiple parameters because currying
    i.e. addThree :: Integer -> Integer -> Integer -> Integer
      := addThree :: Integer -> (Integer -> (Integer -> Integer))
    the parentheses are implied and so can be ignored
#function as parameter
    check :: (t -> Bool) -> t -> Bool
    check f x = if (f x) then True else False
  here the parentheses are necessary and so must be written (unlike with currying)

#Class constraint: everything before the => symbol
  odd :: Integral a => a -> Bool
  class constraint => type signature
#Multiple class constraints:
  sum :: (Num a, Foldable t) => t a -> a

#Type variables
    fst :: (a, b) -> a
  a and b here are not (explicit) types, they're type variables (they can be of any types)
  same type variable in the same signature must be of the same type
    i.e. in fst signature above, if a is Int in the input, it must also be Int in the output
  different type variables don't have to be of different types
    i.e. a and b can be of the same type as in: fst (1,2)
  type variable is much like generics, only much more powerful
    because it allows us to easily write very general functions
    if they don't use any specific behavior of the types in them.
#Polymorphism
  Polymorphic functions: functions that have type variables, so it can be different types on different occasion
  polymorphic constants: constants that can be of different types on different occasion

#-------------------------------------------------------------------------------------
#Typeclass
  typeclass: a sort of interface that defines some behavior.
  If a type is a part of a typeclass, then it inherits the behaviour of the typeclass.

#Basic typeclasses
  #Eq: types that support equality testing
    all standard Haskell types except for I/O and functions are a part of the Eq typeclass.
    if there's an Eq class constraint for a type variable in a function, it uses == or /= somewhere inside its definition.
  #Ord: types that have an ordering
    Ordering is a type that can be GT (greater than), LT(lesser than) or EQ (equal)
    Ord covers all the standard comparing functions such as >, <, >= and <=.
      The compare function takes two Ord members of the same type and returns an ordering.
    to be a member of Ord, a type must also be a member of Eq.
  #Show: types that can be presented as strings.
    The most used function that deals with the Show typeclass is show.
      show 3 -> "3"   #takes a value whose type is a member of Show and presents it to us as a string
  #Read: types that can be read from strings.
    The read function takes a string and returns a type which is a member of Read.
      read "True" || False  ->  True  #not ambiguous because we did something with the result afterwards; GHCi could infer the result is Bool (not String)
      read "4" -> exception error     #ambiguous type; read doesn't know what type we want in return
    #Using type annotations with read to clear ambiguity
      Type annotations: a way of explicitly saying what the type of an expression should be using double semicolon (::)
        (read "5" :: Float) * 4        ->  20.0
        read "[1,2,3,4]" :: [Int]      ->  [1,2,3,4]
        read "(3, 'a')" :: (Int, Char) ->  (3, 'a')
    #Read parameterized type
      We can also read parameterized types, but we have to fill in the type parameters.
      So we can't do
        read "Just 't'" :: Maybe a
      but we can do
        read "Just 't'" :: Maybe Char
  #Enum: sequentially ordered types (can be enumerated, have successor and predecesor)
    we can use Enum types in ranges: [1..3]
    have defined successors and predecesors (which you can get with the succ and pred functions)
    types in this class are Enum: ()/tuple, Bool, Char, Ord, Int, Integer, Float and Double.
  #Bounded: types have an upper and a lower bound.
    minBound and maxBound have a type of (Bounded a) => a. they are polymorphic constants.
      minBound :: Char ->  '\NUL'
    all tuples are also part of Bounded if the components are also in it
      maxBound :: (Bool, Int, Char) ->  (True, 2147483647, '\1114111')
  #Num (numeric typeclass): types that have the property of being able to act like numbers.
      :t 20  ->  20 :: (Num t) => t
    numbers are polymorphic constants. they can act like any type that's a member of the Num typeclass.
    members of the Num typeclass: Int, Integer, Float, Double, etc
    to be a member of Num, a type must also be a member of Show and Eq.
    Num includes all numbers: real numbers and integral numbers
  #Floating (numeric typeclass): includes only floating point numbers (Float and Double)
  #Integral (numeric typeclass): includes only integral/whole numbers (Int and Integer)
    #fromIntegral function
      fromIntegral :: (Num b, Integral a) => a -> b   #takes an integral number, turns it into a more general number
      fromIntegral (length [1,2,3,4]) + 3.2           #delete fromIntegral and you'll get an error of adding Int (length) with Float (3.2)

#Functor, Applicative, Monad
  Functors are for things that can be mapped over
  Applicative functors allowed us
    to apply normal functions between several applicative values
    to take a normal value and put it in some default context
  Monad added the ability for these values with context to somehow be fed into normal functions

#Functor: things that can be mapped over (things whose output can be transformed by a unary function)
    class Functor f where                 #the f here stands for a type constructor that accepts one type parameter
      fmap :: (a -> b) -> f a -> f b      #we can think of fmap as a function that takes a function and a functor and then maps that function over the functor
      fmap :: (a -> b) -> (f a -> f b)    #we can think of fmap as a function that takes a function and lifts that function so that it operates on functors
    instance Functor [] where
      fmap = map
    instance Functor Maybe where
      fmap f (Just x) = Just (f x)        #the f here stands for the function that will be used to map values
      fmap f Nothing = Nothing
    instance Functor Tree where
      fmap f EmptyTree = EmptyTree
      fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)
    instance Functor (Either a) where     #we do 'Either a' instead of just Either because Functor only takes a type constructor with one type parameter
      fmap f (Right x) = Right (f x)      #only the Right will be mapped
      fmap f (Left x) = Left x            #the Left is left as it is
    instance Functor IO where
      fmap f action = do
        result <- action
        return (f result)
    instance Functor ((->) r) where       #we can treat (->) as type constructor that takes two type parameters
      fmap f g = (\x -> f (g x))          #this line and the line below conveys the same behavior
      fmap = (.)                          #fmap is function composition when used on functions
  If you think of functors as things that output values,
    you can think of mapping over functors
    as attaching a transformation to the output of the functor that changes the value.
#Two Functor Laws
  fmap id = id
    if we map the id function over a functor,
    the functor that we get back should be the same as the original functor
  fmap (f . g) = fmap f . fmap g
    composing two functions and then mapping the resulting function over a functor
    should be the same as first mapping one function over the functor and then mapping the other one.
  Every functor must obey the two laws above

#Applicative functors
    class (Functor f) => Applicative f where
      pure :: a -> f a                        #takes a value and puts it in a default context (a minimal context that still yields that value)
      (<*>) :: f (a -> b) -> f a -> f b
      (<$>) :: (a -> b) -> f a -> f b
      f <$> x = fmap f x                      #An infix synonym for fmap
    instance Applicative Maybe where
      pure = Just
      Nothing <*> _ = Nothing
      (Just f) <*> something = fmap f something
    instance Applicative [] where
      pure x = [x]
      fs <*> xs = [f x | f <- fs, x <- xs]
    instance Applicative IO where
      pure = return
      a <*> b = do
        f <- a
        x <- b
        return (f x)
    instance Applicative ZipList where
      pure x = ZipList (repeat x)
      ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
  With ordinary functors, we can just map functions over one functor.
    But with applicative functors, we can apply a function between several functors.
  there are actually more ways for lists to be applicative functors
    with [], calling <*> with a list of functions and a list of values
      results in a list which has all the possible combinations of applying functions
      from the left list to the values in the right list.
    with ZipList
      the first function in the left list gets applied to the first value in the right one,
      the second function gets applied to the second value, etc.
  we have to use the getZipList function to extract a raw list out of a zip list
#Lifting function to operates on multiple functor
    liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
    liftA2 f a b = f <$> a <*> b
  liftA2 takes a normal binary function and promotes it to a function that operates on two functors
  similar function:
    liftA
    liftA3
#Example usage
  (++) <$> Just "johntra" <*> Just "volta"        #return Just "johntravolta"
  filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]   #return [55,80,100,110]
  main = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated is: " ++ a
  getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
    #returns [101,102,103]
  getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
    #returns [('d','c','r'),('o','a','a'),('g','t','t')]

#Monad
    class Applicative m => Monad m where
      return :: a -> m a                  #the same as pure for Applicative; it just takes a normal value and puts it in a context
      (>>=) :: m a -> (a -> m b) -> m b
      (>>) :: m a -> m b -> m b
      x >> y = x >>= \_ -> y              #this doesn't completely ignore x (the computational context is still considered)
      fail :: String -> m a
      fail msg = error msg
    instance Monad Maybe where
      return x = Just x
      Nothing >>= f = Nothing
      Just x >>= f = f x
      fail _ = Nothing
    instance Monad [] where
      return x = [x]
      xs >>= f = concat (map f xs)
      fail _ = []
    instance (Error e) => Monad (Either e) where
      return x = Right x
      Right x >>= f = f x
      Left err >>= f = Left err
      fail msg = Left (strMsg msg)
#do notation
  do expressions are just different syntax for chaining monadic values
    function_name = Monad value >>= (\variable -> (manipulate variable))
    function_name = 
      Monad value >>= (\variable ->
      Monad (manipulate variable))
    function_name = 
      variable <- Monad value
      Monad (manipulate variable)
  the 3 function declaration below is the same:
    foo :: Maybe String
    foo = Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
    foo =
      Just 3   >>= (\x ->
      Just "!" >>= (\y ->
      Just (show x ++ y)))
    foo = do
      x <- Just 3
      y <- Just "!"
      Just (show x ++ y)
  if we change Just 3 or Just "!" to Nothing, the whole function would return Nothing
  When we write a line in do notation without binding the monadic value with <-,
    it's just like putting >> after the monadic value whose result we want to ignore
      routine :: Maybe Pole
      routine = do
          start <- return (0,0)
          first <- landLeft 2 start
          Nothing
          second <- landRight 2 first
          landLeft 1 second
  In do notation, when we bind monadic values to names, we can utilize pattern matching
    justH :: Maybe Char
    justH = do
      (x:xs) <- Just "Hello"
      return x
  When pattern matching fails in a do expression, the fail function is called.

#Writer monad
    newtype Writer w a = Writer { runWriter :: (a, w) }
    instance (Monoid w) => Monad (Writer a) where
      return x = Writer (x, mempty)
      (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
  the attached value of a Writer (the right element of the pair)
    is usually a String used for logging purpose,
    but it can be any monoid value
  when using Writer, use difference list as the monoid for efficient appending (++)
#Reader monad
    instance Monad ((->) r) where
      return x = \_ -> x
      h >>= f = \w -> f (h w) w
    addStuff = (*2) >>= (\a -> (+10) >>= (\b -> return (a+b)))
    addStuff = do
      a <- (*2)
      b <- (+10)
      return (a+b)
    addStuff 3      #returns 19
  the function monad (->) is also called the reader monad
    since all the functions read from a common source
#State monad
    newtype State s a = State { runState :: s -> (a,s) }
    instance Monad (State s) where
      return x = State $ \s -> (x,s)
      (State h) >>= f
        = State $ \s -> let (a, newState) = h s
                            (State g) = f a
                        in  g newState
  stateful computation is a function
    that takes some state
    and returns a value along with some new state
    (e.g. the random function)
  State monad is used to represent stateful computation
  (>>=) :: State s a -> (a -> State s b) -> State s b

#MonadPlus
    class Monad m => MonadPlus m where
      mzero :: m a                      #the same as mempty in Monoid
      mplus :: m a -> m a -> m a        #the same as mappend in Monoid
    instance MonadPlus [] where
      mzero = []
      mplus = (++)
  The MonadPlus type class is for monads that can also act as monoids
#List comprehension
  list comprehensions are just syntactic sugar for using lists as monads
  the 3 function declaration below is the same:
    [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)    #returns [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
    [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]
    listOfTuples = do
      n <- [1,2]
      ch <- ['a','b']
      return (n,ch)
  with guard:
    guard :: (MonadPlus m) => Bool -> m ()
    guard True = return ()
    guard False = mzero
    [ x | x <- [1..50], '7' `elem` show x ]
    [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
    sevensOnly = do
      x <- [1..50]
      guard ('7' `elem` show x)
      return x

#Monoid
    class Monoid m where
      mempty :: m                       #mempty is a polymorphic constant that represents the identity value for a particular monoid
      mappend :: m -> m -> m            #mappend is the binary function of that monoid
      mconcat :: [m] -> m               #mconcat takes a list of monoid values and reduces them to a single value by doing mappend between the list's elements
      mconcat = foldr mappend mempty
    instance Monoid [a] where
      mempty = []
      mappend = (++)
    newtype Product a =  Product { getProduct :: a }  #Sum can also be a monoid with Num
      deriving (Eq, Ord, Read, Show, Bounded)
    instance Num a => Monoid (Product a) where        #notice the 'Num a' class constraint
      mempty = Product 1
      Product x `mappend` Product y = Product (x * y)
    newtype Any = Any { getAny :: Bool }              #All can also be a monoid with Bool
      deriving (Eq, Ord, Read, Show, Bounded)
    instance Monoid Any where
      mempty = Any False
      Any x `mappend` Any y = Any (x || y)
    instance Monoid a => Monoid (Maybe a) where
      mempty = Nothing
      Nothing `mappend` m = m
      m `mappend` Nothing = m
      Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
    newtype First a = First { getFirst :: Maybe a }
      deriving (Eq, Ord, Read, Show)
    instance Monoid (First a) where                   #there's also Data.Monoid.Last
      mempty = First Nothing
      First (Just x) `mappend` _ = First (Just x)
      First Nothing `mappend` x = x
  Monoid characteristics:
    binary function whose parameters and returned value have the same type.
    have identity element
    is associative (the order of application of the binary function doesn't matter)
  Monoid laws:
    mempty `mappend` x = x
    x `mappend` mempty = x
    (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)

#Foldable
    class Foldable t where
      foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
    data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
    instance Data.Foldable.Foldable Tree where
      foldMap f Empty = mempty
      foldMap f (Node x left right) =
        Data.Foldable.foldMap f left
        `mappend` f x
        `mappend` Data.Foldable.foldMap f right
  the minimal complete definition of Foldable is foldMap or foldr
    once you define one of foldMap or foldr, you'll get all Foldable function automatically:
      fold, foldMap, foldr, foldl, foldr1, foldl1, etc.
  Notice that when we define a minimal complete definition
    we didn't have to provide the function f :: (a -> m)
    we receive that function as a parameter to foldMap
      and all we have to decide is where to apply that function and how to join up the resulting monoids from it.
#foldMap
  foldMap comes in handy for reducing a non-monoid Foldable to a single monoid value
    Data.Monoid.getSum $ foldMap (\x -> (Data.Monoid.Sum x)) [1,2,3]          #returns 6
    Data.Monoid.getAny $ foldMap (\x -> Data.Monoid.Any $ x == 3) [1,2,3]     #returns True
    foldMap (\x -> [x]) tree  #turns tree into a list

#-------------------------------------------------------------------------------------
#Pattern matching
  pattern matching: matching a type's value to its value constructor using patterns and extract the data according to those patterns.
  when defining functions, you can define separate function bodies for different patterns
    the patterns will be checked from top to bottom
    and when it conforms to a pattern, the corresponding function body will be used.
  order is important when specifying patterns
    specify the most specific ones first (e.g. base case in recursion first to avoid infinite recursion)
    and then the more general ones later
    and the catch-all default case last (if you put the catch-all at the top, the patterns after it won't get executed)
  pattern matching can fail if we try to call it with an input that we didn't expect
    i.e. pattern will fail if we supply a data and it can't find any pattern that match the data
    we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input
#list pattern matching with as pattern
  the 'as pattern' is a handy way of
    breaking something up according to a pattern and binding it to names
    whilst still keeping a reference to the whole thing
    by putting a name and an @ in front of a pattern.
  we use as patterns to avoid repeating ourselves when matching against a bigger pattern
    when we have to use the whole thing again in the function body.
      e.g. the pattern xs@(x:y:ys) will match exactly the same thing as x:y:ys
        but you can easily get the whole list via xs
        instead of repeating yourself by typing out x:y:ys in the function body again.

#Pattern matching
  #basic pattern matching on parameters in function definitions
    sayMe :: (Integral a) => a -> String
    sayMe 1 = "One!"
    sayMe 2 = "Two!"
    sayMe 3 = "Three!"
    sayMe x = "Not between 1 and 3"       #without this catch-all pattern, sayMe 5 would return an error (the pattern matching will fail)
  #for recursion
    factorial :: (Integral a) => a -> a
    factorial 0 = 1
    factorial n = n * factorial (n - 1)
  #with tuple
    addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
    addVectors a b = (fst a + fst b, snd a + snd b)     #without pattern matching
    addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)   #with pattern matching (using only one catch-all pattern)
  #with list comprehension
    [a+b | (a,b) <- [(1,3), (4,3), (2,4)]] -> [4,7,6]   #the pattern specified here is (a,b)
  #with list
    #basic (x:xs) pattern
        head :: [a] -> a
        head [] = error "Can't call head on an empty list, dummy!"
        head (x:_) = x
      pattern like x:xs will bind the head of the list to x and the rest of it to xs,
        even if there's only one element so xs ends up being an empty list.
      if you want to bind to several variables
        (even if one of them is just _ and doesn't actually bind at all),
        we have to surround them in parentheses.
    #with recursion
        last :: [a] -> a
        last [] = error "empty list"
        last [x] = x                             #(x:[]) could be rewriten as [x]
        last (_:x) = last x
    #binding to more than two variable
        tell :: (Show a) => [a] -> String
        tell [] = "The list is empty"
        tell (x:[]) = "The list has one element: " ++ show x
        tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
        tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
      if you want to bind, say, the first three elements to variables
        and the rest of the list to another variable,
        you can use something like x:y:z:zs.
          this will only match against lists that have 3 elements or more.
    #as patterns
        capital :: String -> String
        capital "" = "empty string!"
        capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
  #with let expression
  #with do notation

#-------------------------------------------------------------------------------------
#Guards
  guards are a way of testing whether some property of a value (or several of them) are True or False
    and then running the function body associated with the guard if it evaluates to True
  guards are a lot more readable than if expression when you have several conditions
    and they play really nicely with patterns.

#Guards
  #basic
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body   #otherwise always evaluate to True
    max' :: (Ord a) => a -> a -> a
    max' a b
      | a > b = a
      | otherwise = b
  #single line
    max' :: (Ord a) => a -> a -> a
    max' a b | a > b = a | otherwise = b
  #with where clause to bind local names
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body
      where
        name = value
        name = value
    bmiTell :: (RealFloat a) => a -> a -> String
    bmiTell weight height
      | bmi <= skinny = "You're underweight, you emo, you!"
      | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"
      | bmi <= fat = "You're fat! Lose some weight, fatty!"
      | otherwise = "You're a whale, congratulations!"
      where
        bmi = weight / height ^ 2
        (skinny, normal, fat) = (18.5, 25.0, 30.0)

#-------------------------------------------------------------------------------------
#Where bindings
  where bindings are a syntactic construct
    that let you bind to variables at the end of a function
    and the whole function can see them, including all the guards.

#Where binding clause
  #in guards
    type_signature
    function_name parameters
      | guard = function_body
      | guard = function_body
      | otherwise = function_body
      where
        name = value
        name = value
  #with pattern matching
    initials :: String -> String -> String
    initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
      where (f:_) = firstname
            (l:_) = lastname
  #in list comprehension
    calcBmis :: (RealFloat a) => [(a, a)] -> [a]
    calcBmis xs = [bmi w h | (w, h) <- xs]
      where bmi weight height = weight / height ^ 2
  #nested
    it's a common idiom to make a function
      and define some helper function in its where clause
      and then to give those functions helper functions as well,
      each with its own where clause.

#-------------------------------------------------------------------------------------
#Let binding
  Let bindings let you bind to variables anywhere
    but are very local, so they don't span across guards.
  Let bindings are expressions (like if expression)
    you can cram it almost anywhere

#Let binding clause
      let <bindings> in <expression>
      4 * (let a = 9 in a + 1) + 2  -> 42
      ghci> let zoot x y z = x * y + z
    The names that you define in the let part are accessible to the expression after the in part.
    We omitted the in part of the let binding when we used them in list comprehensions
      because the visibility of the names is already predefined there.
        But, we could use a let in binding in a predicate and the names defined would only be visible to that predicate.
    The in part can also be omitted when defining functions and constants directly in GHCi.
      If we do that, then the names will be visible throughout the entire interactive session.
  #to introduce function in a local scope
    [let square x = x * x in (square 5, square 3, square 2)] -> [(25,9,4)]
  #with pattern matching
    cylinder :: (RealFloat a) => a -> a -> a
    cylinder r h =
      let sideArea = 2 * pi * r * h
          topArea = pi * r ^2
      in sideArea + 2 * topArea
  #destructuring tuple with pattern matching
    (let (a,b,c) = (1,2,3) in a+b+c) * 100  ->  600
  #bind to several variables inline
    (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
    ->  (6000000,"Hey there!")
  #in list comprehension
    calcBmis :: (RealFloat a) => [(a, a)] -> [a]
    calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]

#-------------------------------------------------------------------------------------
#Case expressions
  It's about taking a variable and then executing blocks of code for specific values of that variable
    and then maybe including a catch-all block of code in case the variable has some value for which we didn't set up a case.

#Case expressions
  case expression of
    pattern -> result
    pattern -> result
    pattern -> result
    ...
  describeList :: [a] -> String
  describeList xs = "The list is " ++ case xs of [] -> "empty."
                                                 [x] -> "a singleton list."
                                                 xs -> "a longer list."
#using pattern matching
  pattern matching on parameters in function definitions
    is just a syntactic sugar for case expressions.
  Because pattern matching in function definitions is syntactic sugar for case expressions,
    we could have also defined the above function like so:
      describeList :: [a] -> String
      describeList xs = "The list is " ++ what xs
        where what [] = "empty."
              what [x] = "a singleton list."
              what xs = "a longer list."

#-------------------------------------------------------------------------------------
#Recursion
  a way of defining functions in which the function is applied inside its own definition.
  making a recursive function:
    you define an edge case
    you define a function that does something between some element and the function applied to the rest.
  usually the identity of an operation used in the recursion is the edge case. e.g.
    in recursive sum (with + operator), the identity and edge case is 0 (since n+0=n)
    with list, the identity is usually an empty list []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted

#-------------------------------------------------------------------------------------
#Higher order functions
  higher order function is a function that
    take functions as parameters
    and/or return functions as return values
#Curried functions
  every function in Haskell only takes one parameter
  functions that take more than one parameter is implemented as curried function
  if we call a (multi-parameter) function with too few parameters,
    we get back a partially applied function (curried function)
#Map + Filter = List comprehension
  you can express list comprehension using a combination of map and filter
    this will make the expression more readable and composable (in some cases)
  The filter equivalent of applying several predicates in a list comprehension
    is either filtering something several times or joining the predicates with the logical && function.
#Fold (reduce)
  fold takes a binary function, a starting value (accumulator), and a list to fold up.
  the accumulator usually use the identity of the operation used in the binary function
  the binary function itself takes two parameters
    which is the accumulator and the first (or last) element (current element)
    and it produces a new accumulator
  many function can be defined using both foldl or foldr
    choose one implementation that is more performant or readable
  we usually use right folds when we're building up new lists from a list (even though we can also use foldl)
    e.g. foldr is more performant (less expensive) than foldl:
      map f xs = foldr (\x acc -> f x : acc) [] xs
      map f xs = foldl (\acc x -> acc ++ [f x]) [] xs
#Lambdas
    Lambdas: anonymous functions that are used once.
    Normally, we make a lambda with the sole purpose of passing it to a higher-order function.
    \ is used because it looks like the greek letter lambda without the small left leg
    if you don't wrap lambda inside parentheses, the function_body will be from '->' to the end of line
    like normal functions, you can pattern match in lambdas
      the only difference is that you can't define several patterns for one parameter
    People who are not well acquainted with how currying works often use lambdas where they don't need to
      e.g. using (map (\x -> x + 3)[1,6,3,2]) instead of (map (+3)[1,6,3,2])
      it's OK to use lambda instead of partial application if it makes your code more readable
#Operator's associativity
  left-associative: the operation is evaluated left to right
    e.g. usual function application with space
  right-associative: the operation is evaluated right to left
    e.g. function composition

#Currying infix function
    divideByTen :: (Floating a) => a -> a
    divideByTen = (/10)
    isUpperAlphanum :: Char -> Bool
    isUpperAlphanum = (`elem` ['A'..'Z'])
  Infix functions can also be partially applied by using sections
  To section an infix function,
    simply surround it with parentheses
    and only supply a parameter on one side.
      That creates a function that takes one parameter
      and then applies it to the side that's missing an operand.
  #Exception
    subtractByFour :: (Floating a) => a -> a
    subtractByFour = (subtract 4)
  you can't use (-4) here because (-4) denotes negative integer 4 (and will not return a partially applied function)

#Map
    map :: (a -> b) -> [a] -> [b]
    map _ [] = []
    map f (x:xs) = f x : map f xs
  map takes a function and a list, and applies that function to every element in the list, producing a new list.
    map (+3) [1,5,3,1,6]    ->    [4,8,6,4,9]
    map (*) [0..]           ->    [(0*),(1*),(2*),(3*),(4*),(5*)...]
      (map (*) [0..]) !! 100        ->    (100*)
      ((map (*) [0..]) !! 100) 4    ->    400
    map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]     ->    [1,3,6,2,2]
#Filter
    filter :: (a -> Bool) -> [a] -> [a]
    filter _ [] = []
    filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
  filter takes a predicate and a list, and then returns the list of elements in the list that satisfy the predicate.
  a predicate is a function that tells whether something is true or not (a function that returns a boolean value)
    filter (==3) [1,2,3,4,5]    ->    [3]
    filter even [1..10]         ->    [2,4,6,8,10]
    let notNull x = not (null x) in filter notNull [[1,2,3], [], [3,4,5], [2,2], [], [], []]    ->    [[1,2,3],[3,4,5],[2,2]]
    filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"    ->    "GAYBALLS"

#Lambdas
  #basic
    (\parameter1 parameter2 -> function_body)
    (\xs -> length xs > 15)
    (\a b -> a+b) 1 2   ->    3
  #with pattern matching
    map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
#Fold (reduce)
    (fold binary_function accumulator list)
  #foldl: folds the list up from the left side
    sum :: (Num a) => [a] -> a
    sum xs = foldl (\acc x -> acc + x) 0 xs
  #foldr: folds the list up from the right side
    map :: (a -> b) -> [a] -> [b]
    map f xs = foldr (\x acc -> f x : acc) [] xs    #notice that the order of x and acc in the binary function is swapped than in foldl
  #foldl1 and foldr1
    foldl1 and foldr1 functions work much like foldl and foldr,
      only you don't need to provide them with an explicit starting value.
    they assume the first (or last) element of the list to be the starting value
      and then start the fold with the element next to it.
    since they depend on the lists they fold up having at least one element,
      they cause runtime errors if called with empty lists.
    if a function doesn't make sense when given an empty list,
      you can probably use a foldl1 or foldr1 to implement it.
#Scan
    scanl (+) 0 [3,5,2,1]         ->    [0,3,8,10,11]
    scanr (+) 0 [3,5,2,1]         ->    [11,8,3,1,0]
    scanl (flip (:)) [] [3,2,1]   ->    [[],[3],[2,3],[1,2,3]]
  scanl and scanr are like foldl and foldr,
    only they report all the intermediate accumulator states in the form of a list.
  When using a scanl, the final result will be in the last element of the resulting list
    while a scanr will place the result in the head.
  there are also scanl1 and scanr1, which are analogous to foldl1 and foldr1.

#The $ function (a.k.a function application operator)
    ($) :: (a -> b) -> a -> b
    f $ x = f x
  Whereas normal function application (putting a space between two things) has a really high precedence,
    the $ function has the lowest precedence.
  Function application with a space is left-associative
    (so f a b c is the same as ((f a) b) c)),
    function application with $ is right-associative.
  Most of the time, $ is a convenience function so that we don't have to write so many parentheses.
    f (g (h x))
      f $ g $ h x
    sum (filter (> 10) (map (*2) [2..10]))
      sum $ filter (>10) $ map (*2) [2..10]
  the existence of $ means that function application can be treated just like another function
    map ($ 3) [(4+), (10*), (^2), sqrt]   ->    [7, 30, 9, 1.7320508075688772]

#Function composition
    (.) :: (b -> c) -> (a -> b) -> a -> c
    f . g = \x -> f (g x)
  One of the uses for function composition is making functions on the fly to pass to other functions.
  You can use lambdas for that, but many times, function composition is clearer and more concise.
    map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]    ->    [-5,-3,-6,-7,-3,-2,-19,-24]
    map (negate . abs) [5,-3,-6,7,-3,2,-19,24]            ->    [-5,-3,-6,-7,-3,-2,-19,-24]
    map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]    ->    [-14,-15,-27]
    map (negate . sum . tail) [[1..5],[3..6],[1..7]]              ->    [-14,-15,-27]
  To use functions that take several parameters in function composition,
  we have to partially apply them just so much that each function takes just one parameter.
    sum (replicate 5 (max 6.7 8.9))
    := (sum . replicate 5 . max 6.7) 8.9   #compose the function and then apply it with 8.9
    := sum . replicate 5 . max 6.7 $ 8.9
  If you want to rewrite an expression with a lot of parentheses by using function composition,
  start by putting the last parameter of the innermost function after a $
  and then compose all the other function calls,
  writing them without their last parameter and putting dots between them.
    replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))
    := replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]

#-------------------------------------------------------------------------------------
#Modules
  module is a collection of related functions, types and typeclasses.
  program is a collection of modules
    where the main module loads up the other modules
    and then uses the functions defined in them to do something.
  Haskell standard library is split into modules
  the Prelude module is imported by default
  When you import a module, all the functions that module exports become available in the global namespace
  You can choose to import all of the functions of a module except a few select ones.
    That's often useful when several modules export functions with the same name
    and you want to get rid of the offending ones.
  Another way of dealing with name clashes is to do qualified imports.
  To search for functions or to find out where they're located, use Hoogle.

#Basic import module: import module_name
#Selective import
  import Data.List (nub, sort)    #import only nub and sort
  import Data.List hiding (nub)   #import everything except nub
#Qualified import: import qualified Data.Map
  This makes it so that if we want to reference Data.Map's filter function,
    we have to do Data.Map.filter,
    whereas just filter refers to the normal filter from Prelude
#Alias for qualified import: import qualified Data.Map as M
  Now, to reference Data.Map's filter function, we just use M.filter.

#Making module
  At the beginning of a module, we specify the module name.
    If we have a file called Geometry.hs, then we should name our module Geometry.
  Then, we specify the functions that it exports
    and after that, we can start writing the functions.
#Example:
  !Geometry.hs
    module Geometry
    ( cubeArea
    , cuboidArea
    ) where

    cubeArea :: Float -> Float
    cubeArea side = cuboidArea side side side

    cuboidArea :: Float -> Float -> Float -> Float
    cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

    rectangleArea :: Float -> Float -> Float
    rectangleArea a b = a * b

  !ghci
    import Geometry

#Making module with submodules
  Modules can also be given a hierarchical structures.
  Each module can have a number of sub-modules and they can have sub-modules of their own.
#Example:
    make a folder called Geometry. Mind the capital G.
    In it, we'll place three files: Sphere.hs, Cuboid.hs, and Cube.hs.
  !Geometry/Sphere.hs
    module Geometry.Sphere
    ( volume
    , area
    ) where

    volume :: Float -> Float
    volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

    area :: Float -> Float
    area radius = 4 * pi * (radius ^ 2)

#Exporting user-defined type
  module Shapes               #remember: this should be at the top of the module file
  ( Shape                     #don't export any value constructors; use other exported functions (e.g. createBaseCircle or createBaseRect) to make Shape
  , Shape(Rectangle, Circle)  #export only Rectangle and Circle value constructors
  , Shape(..)                 #export all value constructors
  , surface
  , nudge
  , createBaseCircle
  , createBaseRect
  ) where                     #define functions and value constructor below the 'where' line

#-------------------------------------------------------------------------------------
#Data declaration (User-defined type)
  data keyword can be used to declare:
    a new type (by not specifying any type parameter)
      data TypeName = Value_constructor fields | Value_constructor fields
    a type constructor (by specifying one or more typeVariable as type parameter)
      data TypeConstructor typeVariable typeVariable = Value_constructor fields | Value_constructor fields
  TYPE NAME AND VALUE CONSTRUCTORS HAVE TO BE CAPITALIZED
  It's common to use the same name as the type if there's only one value constructor
    e.g. data Point = Point Float Float deriving (Show)
  when we pattern matched against values like [], False, or 5,
    we actually pattern matched against value constructors with no fields.
      e.g. False is a value constructor that returns a Bool
#Value Constructor
  value constructors specify the different values that a type can have
  we can optionally add some type variables or type constants (as fields) after a value constructor
  value constructors are actually functions that return a type
      Circle :: Float -> Float -> Float -> Shape
  Since value constructors are functions, we can do functional things to them (like currying, map, etc.)
      e.g. map (Circle 10 20) [4,5,6,6]
#Type Constructor
  type constructors are functions that can take type variables as parameters to produce new types
    data Maybe a = Nothing | Just a
      if we pass Char as the type parameter, the Maybe type constructor returns a type of Maybe Char (or Nothing).
      Nothing is polymorphic since it's type is 'Maybe a' regardless of the type parameter
  the type produced by a type constructor can then be used in functions type declaration
    find :: (a -> Bool) -> [a] -> Maybe a
      the 'Maybe a' type can be used after we define it using the Maybe type constructor
#Automatically deriving typeclass
  Haskell can automatically make our type an instance of any of the following typeclasses:
    Eq, Ord, Enum, Bounded, Show, Read.
  #Eq
    When we derive the Eq instance for a type
      and then try to compare two values of that type with == or /=,
      Haskell will see if the value constructors match
      and then it will check if all the data contained inside matches by testing each pair of fields with ==.
    The types of all the fields (of the value constructor) also have to be part of the Eq typeclass.
  #Show and Read
    The Show and Read typeclasses are for things that can be converted to or from strings, respectively.
    if a value constructors have fields, their type has to be a part of Show or Read
      if we want to make our type an instance of them.
  #Ord
    Ord type class is for types that have values that can be ordered.
    If we compare two values of the same type that were made using different value constructors,
      the value which was made with a constructor that's defined first is considered smaller.
        data Bool = False | True deriving (Ord)
        (False < True)
  #Bounded and Enum
    We can easily use algebraic data types to make enumerations
      and the Enum and Bounded typeclasses help us with that.
    If all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the Enum typeclass.
      data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
#Recursive data structures
  we can make types whose constructors have fields that are of the same type
    data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)

#Using the data keyword to define type
  data TypeName = Value_constructor fields | Value_constructor fields | Value_constructor fields
  data Bool = False | True
  data Shape = Circle Float Float Float | Rectangle Float Float Float Float
#Pattern matching against fields
  surface :: Shape -> Float
  surface (Circle _ _ r) = pi * r ^ 2
  surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
#Deriving type from other types
  data Person =
    Person { firstName :: String
    , lastName :: String
    , age :: Int
    } deriving (Eq, Show, Read)
  data Day =
    Monday | Tuesday | Wednesday |
    Thursday | Friday | Saturday | Sunday
    deriving (Eq, Ord, Show, Read, Bounded, Enum)

#Nesting user-defined types
  data Point = Point Float Float deriving (Show)
  data Shape = Rectangle Point Point deriving (Show)
  surface :: Shape -> Float
  surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
  surface (Rectangle (Point 0 0) (Point 100 100))  ->   10000.0

#Record syntax to define type
  data Person =
    Person
      { firstName :: String
      , lastName :: String
      , age :: Int
      } deriving (Show)
  By using record syntax, Haskell automatically made functions that return the data of that Person: firstName, lastName, age
    :t firstName
    firstName :: Person -> String
#Calling type defined using record syntax
  proper ordering is optional with record syntax, as long as we list all of them:
    data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)
    ghci> Car {model="Mustang", company="Ford", year=1967}
    ->  Car {company = "Ford", model = "Mustang", year = 1967}

#Using the data keyword to define type constructor
  data TypeConstructor typeVariable typeVariable = Value_constructor fields | Value_constructor fields

#-------------------------------------------------------------------------------------
#Type Synonyms
  type synonym makes a synonym for an already existing type
    so that the type is easier to refer to
  type synonyms can be parameterized
    type Dictionary k v = [(k,v)]
  this synonym can then be used anywhere the original type can be used
    type synonyms (and types generally) can only be used in the type portion of Haskell.
    We're in Haskell's type portion whenever we're
      defining new types (so in data and type declarations)
      or when we're located after a ::
        The :: is in type declarations or in type annotations.
  Make sure that you really understand the distinction between type constructors and value constructors.
    Just because we made a type synonym called IntMap or Dictionary
    doesn't mean that we can do stuff like: Dictionary [(1,2),(4,5),(7,9)]

#Declaring type synonym
    type Type_Synonym = Original_Type
  type ID = Int
  type PhoneNumber = String
  type Name = String
  type PhoneBook = [(Name,PhoneNumber)]
  type IntMap v = Map Int v   #partially applied type constructor
#Using type synonym
  inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
  inPhoneBook name phone_number phone_book = (name,phone_number) `elem` phone_book
  read "1" :: ID

#-------------------------------------------------------------------------------------
#Newtype keyword
  The newtype keyword is for
    taking one type and wrapping it in something to present it as another type.
  If you want to take an existing type
    and wrap it in a new type in order to make it an instance of a type class,
    chances are you're looking for a newtype.
  Whereas data can be used to make your own types from scratch,
    newtype is for making a completely new type out of an existing type.
  newtype is faster and lazier than the data keyword
  when you make a new type from an existing type by using the newtype keyword,
      you can only have one value constructor
      and that value constructor can only have one field.
    With data, you can make data types that have
      several value constructors and each constructor can have zero or more fields
  you can use derive with newtype

#Using the newtype keyword to define type
  newtype ZipList a = ZipList { getZipList :: [a] } deriving (Applicative)

#-------------------------------------------------------------------------------------
#Class declaration (User-defined typeclass)
    class TypeClassName typeVariable where
      functions' type annotations
      functions' bodies
    class (SuperTypeClass typeVariable) => SubTypeClassName typeVariable where
      functions' type annotations
      functions' bodies
  you must provide the minimal complete definition for the typeclass
     the minimum of functions that we have to implement so that our type can behave like the class advertises
  you don't have to provide any function body,
    but doing so can decrease the number of minimal complete definition that you have to provide
      e.g. with Eq class below, since we have defined the relation between == and /= in the function bodies,
        we don't have to provide any '/=' definition in the TrafficLight instance declaration
  class constraint is used to make a new typeclass a subclass of an existing typeclass
  to instantiate typeclass on type constructor
    remember to use class constraint on the type constructor's typeVariable (if necessary)
    and to put parentheses around the TypeConstructor and typeVariable to make the them a concrete polymorphic type

#Defining typeclass
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
#Defining typeclass with superclass
  class (Eq a) => Num a where
    functions' type annotations
    functions' bodies
#Instantiating typeclass (on type)
  data TrafficLight = Red | Yellow | Green
  instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
  instance Show TrafficLight where
    show Red = "Red light"
    show Yellow = "Yellow light"
    show Green = "Green light"
#Instantiating typeclass on type constructor
  instance (Eq m) => Eq (Maybe m) where       #remember that (while 'Maybe Char' is a type) 'Maybe' is a type constructor
    Just x == Just y = x == y                 #since x and y (the content of Maybe) must be equatable, we need a class constraint for the content of Maybe
    Nothing == Nothing = True
    _ == _ = False
  instance Truthy (Maybe m) where             #We didn't need a class constraint if we don't assume anything about the content of Maybe
    truthy (Just _) = True
    truthy Nothing = False
  instance Eq a => Eq [a]
  instance (Eq a, Eq b) => Eq (Either a b)

